#include "interp.h"
#include "input.h"
#include "pdb.h"
#include "dcd.h"
#include "util.h"
#include "mutil.h"
#include <math.h>
#include "M_matrix.h"
#include "alignSet.h"
#include "GJK.h"
#include "pcomplex.h"
#include "aux_surfaces.h"
#include "simulation.h"
#include "io_mol_read.h"
#include "face_mask.h"
#include "aa_build_util.h"

//#define DEBUG_PRINT
static double solvation_cutoff = 2.5;
static double solvation_cutoff_MARTINI = 5.0;
static double ion_cutoff = 5.0;
static double PP = 15.0;
//static double PP = 25.0;
static int debug_on = 0;
static int activate_martini = 0;

int doMartini( void ) { return activate_martini; }


const char *charmm_header =
"* GENERATED BY CHARMM-GUI (http://www.charmm-gui.org)\n"
"* ASSEMBLY step.\n"
"*\n"
"\n"
"DIMENS CHSIZE 6000000 MAXRES 6000000\n"
"\n"
"! Read topology and parameter files\n"
"stream toppar.str\n"
"\n";

const char *charmm_footer_build = 
"!\n"
"! Write PSF, coordinates, and information of the assembled system\n"
"!\n"
"\n"
"open write unit 10 card name system.psf\n"
"write psf  unit 10 card\n"
"\n"
"open write unit 10 card name system.crd\n"
"write coor  unit 10 card\n"
"\n"
"open write unit 10 card name system.pdb\n"
"write coor  pdb unit 10\n"
"\n"
"stop\n";

const char *charmm_footer_add = 
"!\n"
"! Write PSF, coordinates, and information of the assembled system\n"
"!\n"
"\n"
"open write unit 10 card name modified.psf\n"
"write psf  unit 10 card\n"
"\n"
"open write unit 10 card name modified.crd\n"
"write coor  unit 10 card\n"
"\n"
"open write unit 10 card name modified.pdb\n"
"write coor  pdb unit 10\n"
"\n"
"stop\n";

double mod_exp( double val );

struct crd_psf_pair
{
	char CRDfileName[256];
	char PSFfileName[256];
};
void EndSegment( FILE *charmmFile, char *cur_filename, char *cur_segment, char *cur_segname,	crd_psf_pair **pairs, int *seg_cntr, int *npairs, int *npair_space, int x_leaflet,
	int *cur_size, int *cur_natoms, int *cur_atom, int *cur_res, int *switched, int gm1_switch );


int TestAdd( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double *cell_shift, double *upper_cen, double *add_to,
	double alpha,
	double main_u_cen,
	double main_v_cen,
	double *use_r, double *source_r,
	double spot_u, double spot_v,
	int fout,
	double *rsurf,
	int leaflet,
	double strain,
	double *dx_uv,
	double *dy_uv,	
	double w_use,
	double w_rim,
	double *rimp,
	double *rimn,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,
	aa_build_data *buildData,

	int **local_cycle,
	int *local_cycle_len,
	int ncycle,
	
	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offset,
	
	FILE *doubleBondIndexes,
	int is_mod  // was this modified to put a protein here?
	);

	struct build_pass
	{
		int structure_take_from; // the index of the PDB/PSF to get the structure
		double min_cut[3]; // the cartesian value below which we don't use this structure (for hemifusion, etc)
		double max_cut[3]; // the cartesian value above which we don't use this structure
		surface *useSurface;
		double *rsurf;
		surface_mask *theMask;
		double strain;
		int orientation; // normal in or out.
	};

void surface::createAllAtom( Simulation *theSimulation, parameterBlock *block, pcomplex **allComplexes, int ncomplex )
{
	int build_mode = block->create_all_atom;

	double *rsurf = (double *)malloc( sizeof(double) * 3 * (1 + nv) );

	PP = block->neutral_surface;
	
	get(rsurf);
	rsurf[3*nv+0] = 1.0;
	rsurf[3*nv+1] = 1.0;
	rsurf[3*nv+2] = 1.0;

	// write the mesh we are building into all-atom. Remove this later but I need it to debug.


	// outputs in CHARMM coordinate format

	// breakdown system into as many approximately square patches as possible, with the correct areas?

	char fileName[256+strlen(block->jobName)];

	if( build_mode == CREATE_SYSTEM )
		sprintf(fileName, "create_%s_charmm.inp", block->jobName );
	else
		sprintf(fileName, "modify_%s_charmm.inp", block->jobName );

	FILE *charmmFile = fopen(fileName,"w");

	if( !charmmFile )
	{
		printf("Couldn't open file \"%s\" for writing.\n", fileName );
		exit(1);
	}
	
	fprintf(charmmFile, "%s", charmm_header );

	if( build_mode == CREATE_SYSTEM )
	{
		if( !block->innerPatchPDB && !block->outerPatchPDB)
		{
			printf("System building requires a valid pdb file, \"patchPDB\", \"innerPatchPDB\", or \"outerPatchPDB\"\n");
			exit(1); 
		}
	}

	int system_pool = -1;

	if( build_mode == CREATE_ADD_COMPLEXES )
	{
		if( ! block->system_psf || !block->system_coords )
		{
			printf("Adding complexes to a structure requires \"psf\" and \"coords\" for the pre-existing system to be set.\n");
			exit(1);
		}
				
		system_pool = addStructureToPool( block->system_coords, block->system_psf );	

		if( poolIsMartini( system_pool ) )
			activate_martini = 1;

		// pin the mesh PBC to that of the simulation?

	}

	int do_leaflet[3] = { 0,0,0 };
	
	int halve[3] = { block->halve_X, block->halve_Y, block->halve_Z };

	char *doubleBondFile = (char *)malloc( sizeof(char) * (strlen(block->jobName) + 1 + strlen(".indx") ) );
	sprintf(doubleBondFile, "%s.indx", block->jobName );
	FILE *doubleBondIndexes = (FILE *)fopen( doubleBondFile, "w" );
	if( !doubleBondIndexes )
	{
		printf("Couldn't open double-bond index file for writing ('%s').\n", doubleBondFile);
		exit(1);
	}
	free(doubleBondFile);

	double total_charge       = 0;
	double protein_charge_inner       = 0;
	double protein_charge_outer       = 0;
	double total_lipid_charge[3] = {0,0,0};

	struct atom_rec *solvate;
	int nsolvate=0;
	double solvate_PBC[3] = { -1,-1,-1};

	if( block->solvatePDB )
	{
		FILE *pdbFile = fopen(block->solvatePDB, "r" );

		if( !pdbFile )
		{
			printf("Couldn't open file \"%s\"\n", block->solvatePDB );
			exit(1);
		}
	
		if( block->solvatePSF )
		{
			FILE *psfFile = fopen(block->solvatePSF,"r");
			
			if( !psfFile )
			{
				printf("Couldn't open file \"%s\"\n", block->solvatePSF );
				exit(1);
			}
	
			loadPSF( psfFile );
		
		}
		else
			loadPSFfromPDB( pdbFile );
			
		nsolvate= curNAtoms();
			
		solvate = (struct atom_rec *)malloc( sizeof(struct atom_rec ) * nsolvate );
		rewind(pdbFile);
		loadPDB( pdbFile, solvate );
		
		if( !strcasecmp( solvate[0].atname, "W") )	
			activate_martini = 1;
		if( !strcasecmp( solvate[0].atname, "PW") )	
			activate_martini = 1;

		double alpha,beta,gamma;
		if( PBCD( solvate_PBC+0,solvate_PBC+1,solvate_PBC+2,&alpha,&beta,&gamma) )
		{
			printf("Couldn't read CRYST1 record from solvation PDB.\n");
			exit(1);
		}
	}

	if( activate_martini )
	{
		printf("Using MARTINI based solute/solvent cutoff.\n");
		solvation_cutoff = solvation_cutoff_MARTINI;
	}

	solvation_cutoff *= block->scale_solvent_approach;

	struct atom_rec *pcomplex_atoms = NULL;
	int npcomplex_atoms = 0;
	
	// aa_build_data stores all of the bonds, cycles and atom positions of what we've added to detect clashes.	
	struct aa_build_data *buildData = (struct aa_build_data *)malloc( sizeof(struct aa_build_data) );

	double boxl = 5.0;
	int nx = PBC_vec[0][0]/boxl;
	int ny = PBC_vec[1][1]/boxl;
	int nz = PBC_vec[2][2]/boxl;

	buildData->init();
	buildData->setupBoxing( PBC_vec, nx, ny, nz);
	buildData->halve[0] = halve[0];
	buildData->halve[1] = halve[1];
	buildData->halve[2] = halve[2];
	int added_pcomplex_ions = 0;

	int pass_pool_id[3] = { -1, -1, -1 };

	if( build_mode == CREATE_SYSTEM )
	{
		for( int pass = 0; pass < 3; pass++ )
		{
			if( pass == 0 && block->innerPatchPDB )
			{
				do_leaflet[pass] = 1;
				pass_pool_id[pass] = addStructureToPool( block->innerPatchPDB, block->innerPatchPSF );	
				if( !getPool(pass_pool_id[pass])->has_pbc )
				{
					printf("Could not read PBC info (required) from %s.\n", block->innerPatchPDB );
					exit(1);
				}
		
				if( getPool(pass_pool_id[pass])->bonds == NULL )
				{
					printf("Building structure requires PSF information (%s).\n", block->innerPatchPDB );
					exit(1);
				}
			}
			else if( pass == 1 && block->outerPatchPDB ) 
			{
				do_leaflet[pass] = 1;
				pass_pool_id[pass] = addStructureToPool( block->outerPatchPDB, block->outerPatchPSF );	
				if( !getPool(pass_pool_id[pass])->has_pbc )
				{
					printf("Could not read PBC info (required) from %s.\n", block->outerPatchPDB );
					exit(1);
				}
				
				if( getPool(pass_pool_id[pass])->bonds == NULL )
				{
					printf("Building structure requires PSF information (%s).\n", block->outerPatchPDB );
					exit(1);
				}
			}
			else if( pass == 2 && block->altPatchPDB )
			{
				do_leaflet[pass] = 1;
				pass_pool_id[pass] = addStructureToPool( block->altPatchPDB, block->altPatchPSF );	
				if( !getPool(pass_pool_id[pass])->has_pbc )
				{
					printf("Could not read PBC info (required) from %s.\n", block->altPatchPDB );
					exit(1);
				}
			}
			else if( block->patchPDB )
			{
				do_leaflet[pass] = -1;
				pass_pool_id[pass] = addStructureToPool( block->patchPDB, block->patchPSF );	
				if( !getPool(pass_pool_id[pass])->has_pbc )
				{
					printf("Could not read PBC info (required) from %s.\n", block->patchPDB );
					exit(1);
				}
				
				if( getPool(pass_pool_id[pass])->bonds == NULL )
				{
					printf("Building structure requires PSF information (%s).\n", block->patchPDB );
					exit(1);
				}
			}
		}
	}

	if( do_leaflet[0] > 0 && do_leaflet[1] == -1 )
		do_leaflet[1] = 0;
	else if( do_leaflet[1] > 0 && do_leaflet[0] == -1 )
		do_leaflet[0] = 0;

	// these masks have blobs of faces where contiguous bits of simulated bilayers are built in.	
	surface_mask *upper_leaflet_mask = (surface_mask *)malloc( sizeof(surface_mask) );
	surface_mask *lower_leaflet_mask = (surface_mask *)malloc( sizeof(surface_mask) );

	double target_area_upper;
	double target_area_lower;
	double dz_rim = 20.0;
	double rim_extent_upper = 0;
	double rim_extent_lower = 0;

	if( build_mode == CREATE_SYSTEM )
	{
		target_area_lower = getPool(pass_pool_id[1])->Lx *  getPool(pass_pool_id[1])->Ly / 4;
		target_area_upper = getPool(pass_pool_id[0])->Lx *  getPool(pass_pool_id[0])->Ly / 4;
	
		upper_leaflet_mask->build( this, rsurf, target_area_upper );
		lower_leaflet_mask->build( this, rsurf, target_area_lower );
		upper_leaflet_mask->applyPoolToAllRegions( pass_pool_id[0] );
		lower_leaflet_mask->applyPoolToAllRegions( pass_pool_id[1] );
	}
	
	int n_nsegs_for_complex = ncomplex+1;
	int nsegs_for_complex[n_nsegs_for_complex];
		
	if( system_pool >= 0 )
	{
		buildData->addSystemPool( system_pool );
		if( build_mode == CREATE_ADD_COMPLEXES )
			buildData->activateAddMode();
	}

	if( ncomplex > 0 )
	{
		// for now, one segment per pcomplex.

		struct ion_add *add_ions = (struct ion_add *)malloc( sizeof(ion_add) * 10 );
		int nions = 0;

		int loop_num=0;
		int pcomp_start = 0;


		for( int p = 0; p < ncomplex; p++ )
		{
			int cur_placed = buildData->curPlace();
			char **seq_arr = NULL;
			int *seq_at_array = NULL;
			int nseq= 0;
			int ion_mark = nions;
			char **patches;
			int build_type;
			allComplexes[p]->writeStructure( theSimulation, upper_leaflet_mask, lower_leaflet_mask, &pcomplex_atoms, &npcomplex_atoms, &seq_arr, &nseq, &seq_at_array, &patches, &add_ions, &nions, buildData, &build_type );
			
			int ntot_plus = buildData->curPlace() - cur_placed;	
			int ntot = npcomplex_atoms - pcomp_start;
			if( buildData->inAddMode() )
				buildData->deleteClashes( cur_placed, ntot_plus );
			nsegs_for_complex[p]=0;

			double pcharge = 0;	

			for( int i = ion_mark; i < nions; i++ )
			{
				switch( add_ions[i].type )
				{
					case ION_CAL:
						pcharge += 2;
						break;
					case ION_MG:
						pcharge += 2;
						break;
					case ION_FE:
						pcharge += 2;
						break;
				}
			}

			if( build_type == BUILD_SEQUENCE ) // protein is built from its sequence, not an RTF.
			{
				if( !seq_arr ) continue;

				nsegs_for_complex[p]=nseq;
				// the total number of atoms added.
				//
				int ntot = npcomplex_atoms - pcomp_start;
			
				for( int s = 0; s < nseq; s++ )
				{
					int nuse = npcomplex_atoms - pcomp_start;
	
					if( s < nseq-1 )
						nuse = seq_at_array[s+1] - seq_at_array[s];
	
					char * seq = seq_arr[s];
	
					for( int t = 0; t < strlen(seq); t++ )
					{
						switch( seq[t] )
						{
							case 'D':
							case 'E':
								pcharge -= 1;
								break;
							case 'R':
							case 'K':
								pcharge += 1;
								break;
						}
					}
			
					if( !activate_martini )
					{
						// For the C-terminal COO-
						pcharge -= 1;
					}
	
					char fileName[256];
					sprintf(fileName, "pcomp_%d_%c_%s.pdb", p, 'A'+s, block->jobName );
		
					FILE *createPCompPDB = fopen(fileName,"w");
		
					// write SEQRES to add in missing residues.
			
					writeSEQRES( createPCompPDB, seq, activate_martini );
		
					char use_segid[256];
					
					if( p < 10 )
						sprintf(use_segid, "p0%d%c", p, 'A' + s );
					else if( p < 100 )
						sprintf(use_segid, "p%d%c", p, 'A' + s );
		
					for( int tp = pcomp_start, xp = 0; xp < nuse && tp < npcomplex_atoms; tp++, xp++ )
					{
						char *temp = pcomplex_atoms[tp].segid;
						pcomplex_atoms[tp].segid = use_segid;				
						if( pcomplex_atoms[tp].atname[0] != 'H' )
						{
							printATOM( createPCompPDB, pcomplex_atoms[tp].bead, pcomplex_atoms[tp].res, pcomplex_atoms+tp ); 
						}
						pcomplex_atoms[tp].segid = temp;
					}
					fprintf(createPCompPDB, "END\n");
					fclose(createPCompPDB);
		
					fprintf(charmmFile, "open read card unit 10 name \"%s\"\n", fileName );	
					if( activate_martini )
					fprintf(charmmFile, "read sequence PDB SEQRES unit 10\n"
							    "generate %s setup warn\n", use_segid );	
					else
					fprintf(charmmFile, "read sequence PDB SEQRES unit 10\n"
							    "generate %s setup warn ACE last CTER\n", use_segid );	
	
					if( pcomplex_atoms[pcomp_start].res != 1 )
					{
						fprintf(charmmFile,
							"set s %d\n"
							"label loop%d\n"
							"calc r = @S + %d\n"
							"RENAme RESId @R sele RESID @S end\n"
							"incr s by -1\n"
							"if s gt 0 goto loop%d\n", strlen(seq), loop_num, pcomplex_atoms[pcomp_start].res-1, loop_num );
						loop_num++;			
					}
	
					if( patches[s] )
					{
						char patchFileName[256];
						sprintf(patchFileName, "%s.patch", use_segid ); 
						FILE *patchFile = fopen(patchFileName,"w");
						// writes patch locally, replacing the segment name.
						processPatch( patches[s], patchFile, use_segid );
						fclose(patchFile);
						fprintf(charmmFile, "stream \"%s\"\n", patchFileName );
					}
	
		
					fprintf(charmmFile, "open write unit 10 card name \"%s.psf\"\n", use_segid);
					fprintf(charmmFile, "write psf  unit 10 card\n");
		
					fprintf(charmmFile, "open read card unit 10 name \"%s\"\n",  fileName );	
					fprintf(charmmFile, "read coor unit 10 pdb resi\n");
		
					if( ! activate_martini )
					{
						fprintf(charmmFile, "ic param\n");
						fprintf(charmmFile, "ic build\n");
						fprintf(charmmFile, "hbuild sele all end\n");
					}
					fprintf(charmmFile, "nbonds atom switch cdie vdw vfswitch  -\n"
		"       ctonnb 10.0 ctofnb 12.0 cutnb 14.0 cutim 16.0 -\n"
		"       inbfrq -1 imgfrq -1 wmin 1.0 cdie eps 80.0\n" );

		if( !activate_martini )
		{
		fprintf(charmmFile, 
		"energy\n"
		"mini sd nstep 200 nprint 10\n" );
		}			
					fprintf(charmmFile, "open write unit 10 card name \"%s.crd\"\n", use_segid );
					fprintf(charmmFile, "write coor unit 10 card\n");
					fprintf(charmmFile, "delete atom sele atom * * * end\n");
		
					fflush(charmmFile);
				
					pcomp_start += nuse;
				}
	
				if( allComplexes[p]->is_inside )
					protein_charge_inner += pcharge;
				else
					protein_charge_outer += pcharge;
			}
			else if( build_type == BUILD_GENERAL )
			{
				// currently only one segment.
				
				int ntot = npcomplex_atoms - pcomp_start;

				nsegs_for_complex[p]=1;

				for( int s = 0; s < 1; s++ )
				{
					int nuse = ntot;

					char fileName[256];
					sprintf(fileName, "pcomp_%d_%c_%s.pdb", p, 'A'+s, block->jobName );
		
					FILE *createPCompPDB = fopen(fileName,"w");
		
					char use_segid[256];
				
					if( p < 10 )
						sprintf(use_segid, "p0%d%c", p, 'A' + s );
					else if( p < 100 )
						sprintf(use_segid, "p%d%c", p, 'A' + s );
		
					for( int tp = pcomp_start, xp = 0; xp < nuse && tp < npcomplex_atoms; tp++, xp++ )
					{
						char *temp = pcomplex_atoms[tp].segid;
						pcomplex_atoms[tp].segid = use_segid;				
//						if( pcomplex_atoms[tp].atname[0] != 'H' )
						{
							printATOM( createPCompPDB, pcomplex_atoms[tp].bead, pcomplex_atoms[tp].res, pcomplex_atoms+tp ); 
						}
						pcomplex_atoms[tp].segid = temp;
					}

					fprintf(createPCompPDB, "END\n");
					fclose(createPCompPDB);

					fprintf(charmmFile, "stream \"%s_%d.str\"\n", "PCOMPLEX_RTF", allComplexes[p]->my_id  );	
		
					fprintf(charmmFile, "open read card unit 10 name \"%s\"\n", fileName );	
					fprintf(charmmFile, "read sequence pdb unit 10\n");	
					fprintf(charmmFile, "generate %s setup warn\n", use_segid );	

		
					fprintf(charmmFile, "open write unit 10 card name \"%s.psf\"\n", use_segid);
					fprintf(charmmFile, "write psf  unit 10 card\n");
		
					fprintf(charmmFile, "open read card unit 10 name \"%s\"\n",  fileName );	
					fprintf(charmmFile, "read coor unit 10 pdb\n");
		
					fprintf(charmmFile, "open write unit 10 card name \"%s.crd\"\n", use_segid );
					fprintf(charmmFile, "write coor unit 10 card\n");
					fprintf(charmmFile, "delete atom sele atom * * * end\n");
			
					fflush(charmmFile);
					
					pcomp_start += nuse;
				}
			}
		}
	
		if( nions > 0 )
		{
			char fileName[256];
			sprintf(fileName,"%s_extra_ions.pdb", block->jobName );
			FILE *add_ions_file = fopen(fileName,"w");

			char ionSeg[256];
			sprintf(ionSeg,"IONS");
			for( int i = 0; i < nions; i++ )
			{	
				struct atom_rec lat;

				char ionName[256];
				switch( add_ions[i].type )
				{
					case ION_CAL:
						sprintf(ionName, "CAL");
						break;
					case ION_MG:
						sprintf(ionName, "MG");
						break;
					case ION_FE:
						sprintf(ionName, "FE");
						break;
				}
				lat.atname = ionName;
				lat.resname= ionName;
				lat.segid  = ionSeg;
				lat.altloc = ' ';
				lat.chain = ' ';
				lat.bead = i+1;
				lat.res = i+1;
				lat.x = add_ions[i].x;	
				lat.y = add_ions[i].y;	
				lat.z = add_ions[i].z;	

				printATOM( add_ions_file, i+1, i+1, &lat ); 
			}
			fprintf(add_ions_file, "END\n");
			fclose(add_ions_file);

			fprintf(charmmFile,
"open read card unit 10 name \"%s_extra_ions.pdb\"\n"
"read sequence PDB  unit 10\n"
"generate IONS setup warn noangle nodihedral\n"

"open write unit 10 card name \"%s_extra_ions.psf\"\n"
"write psf  unit 10 card\n"
"open read card unit 10 name \"%s_extra_ions.pdb\"\n"
"read coor unit 10 pdb resi\n"
"open write unit 10 card name \"%s_extra_ions.crd\"\n"
"write coor unit 10 card\n"
"delete atom sele atom * * * end\n", block->jobName, block->jobName, block->jobName, block->jobName );
			added_pcomplex_ions = 1;

		}

		buildData->markPcut();
	}
	
	int npairs = 0;
	int npair_space = 10;
	crd_psf_pair *pairs = (crd_psf_pair *)malloc( sizeof(crd_psf_pair) * npair_space );

	// may set the rim center, if built
	double rim_center[3]={0,0,0};

	if( build_mode == CREATE_SYSTEM )
		buildLipids( block, rsurf, buildData, halve, charmmFile, doubleBondIndexes, &pairs, &npairs, &npair_space, total_lipid_charge, upper_leaflet_mask, lower_leaflet_mask, pass_pool_id, do_leaflet, rim_center, &rim_extent_upper, &rim_extent_lower );
	
	double rel_vol[2] = {0,0};

	double **M;
	int mlow = 4;
	int mhigh = 8;

	getM(&M,&mlow,&mhigh);	
	
	if( block->addSalt )
	{
		printf("Computing relative volumes inside/outside.\n");

		int n_vol_mc = 1000;

		for( int i = 0; i < n_vol_mc; i++ )
		{
			double rpt[3] = { rand()/(double)RAND_MAX * PBC_vec[0][0],
					  rand()/(double)RAND_MAX * PBC_vec[1][1],
					  rand()/(double)RAND_MAX * PBC_vec[2][2] };
		
			int f;
			double u, v;
			double distance;

			nearPointOnBoxedSurface( rpt, &f, &u, &v, M, mlow, mhigh, &distance, 0 );	
			double nearp[3], nearn[3];
                	evaluateRNRM( f, u, v, nearp, nearn, rsurf );

			double dr[3] = { rpt[0] - nearp[0], rpt[1] - nearp[1], rpt[2] - nearp[2] };
			wrapPBC( dr, rsurf+3*nv );
	
			double io = dr[0] * nearn[0] + dr[1] * nearn[1] + dr[2] * nearn[2];

			if( io < 0 ) // displacement and normal are oppositely aligned, inside the surface (relative to the normal convention) 
				rel_vol[0] += 1;
			else
				rel_vol[1] += 1;	
		}


		printf("rel vol: %lf %lf\n", rel_vol[0], rel_vol[1] );
	}

	total_charge = protein_charge_inner + protein_charge_outer + total_lipid_charge[0] + total_lipid_charge[1];

	
	/* Solvate */

	int wrote_water_psf = 0;
	char waterFileName[256];
	char waterPSFName[256];
	int water_atom = 1;
	int nK[2] = {0,0};
	int nCl[2] = {0,0};

	if( nsolvate > 0 )
	{
		// we need to loop over a sufficient number of solvent periodic boxes to cover the main PBC cell.
		
		int nsolvent_x = ceil(PBC_vec[0][0] / solvate_PBC[0]);
		int nsolvent_y = ceil(PBC_vec[1][1] / solvate_PBC[1]);
		int nsolvent_z = ceil(PBC_vec[2][2] / solvate_PBC[2]);

	

		if( halve[0] ) nsolvent_x = ceil(PBC_vec[0][0] / solvate_PBC[0] / 2);
		if( halve[1] ) 	nsolvent_y = ceil(PBC_vec[1][1] / solvate_PBC[1] / 2);
		if( halve[2] ) 	nsolvent_z = ceil(PBC_vec[2][2] / solvate_PBC[2] / 2);

		// we don't want to do solvent PBC loops over the main cell. we only want to keep residues that are inside the box.
		// make sure the interior coordinates are centered properly.

		// get solvent residue structure in the form of an index.
		int nsolventRes =0;
		int *solvent_res_link = (int *)malloc( sizeof(int) * nsolvate );
		int *solvent_res_size = (int *)malloc( sizeof(int) * nsolvate );

		int pres = -1;
		for( int a = 0; a < nsolvate; a++ )
		{
			if( solvate[a].res != pres )
			{
				if( nsolventRes > 0 )
					solvent_res_size[nsolventRes-1] = a - solvent_res_link[nsolventRes-1];
				solvent_res_link[nsolventRes] = a;
				nsolventRes++;
			}

			pres = solvate[a].res;
		}
				
		solvent_res_size[nsolventRes-1] = nsolvate - solvent_res_link[nsolventRes-1];
		
		printf("%d solvent residues.\n", nsolventRes );

		for( int r = 0; r < nsolventRes; r++ )
		{
			double com[3] = {0,0,0};

			for( int ax = 0; ax < solvent_res_size[r]; ax++ )
			{	
				int a = solvent_res_link[r] + ax;
				com[0] += solvate[a].x;
				com[1] += solvate[a].y;
				com[2] += solvate[a].z;
			}

			com[0] /= solvent_res_size[r];
			com[1] /= solvent_res_size[r];
			com[2] /= solvent_res_size[r];
			
			double shift[3] = {0,0,0};
			while( com[0] + shift[0] < -solvate_PBC[0]/2 ) shift[0] += solvate_PBC[0];
			while( com[1] + shift[1] < -solvate_PBC[1]/2 ) shift[1] += solvate_PBC[1];
			while( com[2] + shift[2] < -solvate_PBC[2]/2 ) shift[2] += solvate_PBC[2];
			while( com[0] + shift[0] > solvate_PBC[0]/2 ) shift[0] -= solvate_PBC[0];
			while( com[1] + shift[1] > solvate_PBC[1]/2 ) shift[1] -= solvate_PBC[1];
			while( com[2] + shift[2] > solvate_PBC[2]/2 ) shift[2] -= solvate_PBC[2];

			for( int ax = 0; ax < solvent_res_size[r]; ax++ )
			{	
				int a = solvent_res_link[r] + ax;

				solvate[a].x += shift[0];
				solvate[a].y += shift[1];
				solvate[a].z += shift[2];
			}
		}


//		double solvation_shift[3] = 
//			{
//				( nsolvent_x * solvate_PBC[0]- PBC_vec[0][0])/2, 
//				( nsolvent_y * solvate_PBC[1]- PBC_vec[1][1])/2, 
//				( nsolvent_z * solvate_PBC[2]- PBC_vec[2][2])/2
//			};	
	
		printf("WATER PBC: %lf %lf %lf\n", nsolvent_x * solvate_PBC[0],
						   nsolvent_y * solvate_PBC[1],	
						   nsolvent_z * solvate_PBC[2] );	
		sprintf(waterFileName, "solvate_%s.crd", block->jobName );

		FILE *waterCRD = fopen(waterFileName, "w" );
		int nprint_solvate = 0;	
		int water_size = 0;
		int water_space =4096;
		char *water_file = (char *)malloc( sizeof(char) * water_space );	 
		water_file[0] = '\0';
		char solventSegName[256];
		sprintf(solventSegName, "WAT");
		int water_res = 1;
		
		double tiling_min[3] =
		{ -solvate_PBC[0]/2, -solvate_PBC[1]/2, -solvate_PBC[2]/2 };
		double tiling_max[3] =
		{ (0.5 + nsolvent_x-1 ) * solvate_PBC[0], 
		  (0.5 + nsolvent_y-1 ) * solvate_PBC[1], 
		  (0.5 + nsolvent_z-1 ) * solvate_PBC[2] };
	
		double tile_center_shift[3] = { 
				  - (tiling_min[0]+tiling_max[0])/2,
				  - (tiling_min[1]+tiling_max[1])/2,
				  - (tiling_min[2]+tiling_max[2])/2 };

		for( int sx = 0; sx < nsolvent_x; sx++ )
		for( int sy = 0; sy < nsolvent_y; sy++ )
		for( int sz = 0; sz < nsolvent_z; sz++ )
		{
			double outer_shift[3] = { 
				tile_center_shift[0] + sx * solvate_PBC[0],
				tile_center_shift[1] + sy * solvate_PBC[1],
				tile_center_shift[2] + sz * solvate_PBC[2] };
		
			for( int r = 0; r < nsolventRes; r++ )
			{	
				double rcom[3] = {0,0,0};
		
				for( int ax = 0; ax < solvent_res_size[r]; ax++ )
				{
					int a = solvent_res_link[r] + ax;
					rcom[0] += solvate[a].x;
					rcom[1] += solvate[a].y;
					rcom[2] += solvate[a].z;
				}	

				rcom[0] /= solvent_res_size[r];
				rcom[1] /= solvent_res_size[r];
				rcom[2] /= solvent_res_size[r];
			
				double sub_shift[3] = { 0,0,0};
				for( int c = 0; c < 3; c++ )
				{
					while( rcom[c] +sub_shift[c] < -solvate_PBC[c]/2 ) sub_shift[c] += solvate_PBC[c];				
					while( rcom[c] +sub_shift[c] >  solvate_PBC[c]/2 ) sub_shift[c] -= solvate_PBC[c];				
				}
	
				outer_shift[0] += sub_shift[0];
				outer_shift[1] += sub_shift[1];
				outer_shift[2] += sub_shift[2];


				rcom[0] += outer_shift[0];
				rcom[1] += outer_shift[1];
				rcom[2] += outer_shift[2];

				if( halve[0] ) rcom[0] += buildData->frac_cen[0] * PBC_vec[0][0];
				if( halve[1] ) rcom[1] += buildData->frac_cen[1] * PBC_vec[1][1];
                                if( halve[2] ) rcom[2] += buildData->frac_cen[2] * PBC_vec[2][2];
				
				if( ! block->perfect_solvent_tiling )
				{
					double dr_rcom[3] = { 
						rcom[0] / PBC_vec[0][0],
						rcom[1] / PBC_vec[1][1],
						rcom[2] / PBC_vec[2][2] };
					
					double dr_fr[3] = { 
						dr_rcom[0] - buildData->frac_cen[0],
						dr_rcom[1] - buildData->frac_cen[1],
						dr_rcom[2] - buildData->frac_cen[2] };
		/* don't do PBC, exclude stuf outside the bounds.			
					while( dr_fr[0] < -0.5 ) dr_fr[0] += 1;
					while( dr_fr[1] < -0.5 ) dr_fr[1] += 1;
					while( dr_fr[2] < -0.5 ) dr_fr[2] += 1;
					while( dr_fr[0] > 0.5 ) dr_fr[0] -= 1;
					while( dr_fr[1] > 0.5 ) dr_fr[1] -= 1;
					while( dr_fr[2] > 0.5 ) dr_fr[2] -= 1;
		*/	
					int continue_flag = 0;

					for( int c = 0; c < 3; c++ )
					{
						if( halve[c] )
						{
							if( dr_fr[c] < -0.25 || dr_fr[c] > 0.25 )
								continue_flag=1;
						}
						else 
						{
							if( dr_fr[c] < -0.5 || dr_fr[c] > 0.5 )
								continue_flag=1;
						}
					}
					if( continue_flag ) continue;
				}
			
				if( block->do_rim )
				{
					// if it's in the rim, don't add it.
					
					double dr_cen[3] = { rcom[0] - rim_center[0],
								    rcom[1] - rim_center[1],
								    rcom[2] - rim_center[2] };
				
					double r_xy = sqrt(dr_cen[0]*dr_cen[0]+dr_cen[1]*dr_cen[1]);

					if( dr_cen[2] <  dz_rim && dr_cen[2] > -dz_rim && r_xy < (rim_extent_upper+rim_extent_lower)/2+10 )
					 	continue; 
				}

				int bad_res = buildData->nclash_aa( rcom, 1, 0, solvation_cutoff, halve ); 


				if( !bad_res )
				{	// add to the pool of water, ha ha.
					for( int ax = 0; ax < solvent_res_size[r]; ax++ )
					{
						int a = solvent_res_link[r] + ax;
						if( water_size + 1024 > water_space )
						{	
							water_space += 1024;
							water_file = (char *)realloc( water_file, sizeof(char) * water_space );
						}
						double savex = solvate[a].x;
						double savey = solvate[a].y;
						double savez = solvate[a].z;
						solvate[a].bead = water_atom;
						solvate[a].res = water_res;
						solvate[a].segRes = water_res;
						solvate[a].x += outer_shift[0];					
						solvate[a].y += outer_shift[1];					
						solvate[a].z += outer_shift[2];					
						char *tseg = solvate[a].segid;
						solvate[a].segid = solventSegName;
						printSingleCRD( water_file+water_size, solvate+a );
						water_size += strlen(water_file+water_size); // move to end of written string.
						nprint_solvate++;
						solvate[a].segid = tseg;
						solvate[a].x = savex;
						solvate[a].y = savey;
						solvate[a].z = savez;
						water_atom++;
					}
					water_res++;
				}

			}
		}	
								
		printCRDHeader( waterCRD, nprint_solvate );
		fprintf(waterCRD, "%s", water_file );
		fclose(waterCRD);

		free(water_file);
	
			fprintf(charmmFile, 
			"\n"
			"open read card unit 10 name \"%s\"\n"
			"read sequence coor card unit 10\n"
			"generate %s setup warn first none last none noangle nodihedral\n"
			"open read unit 10 card name \"%s\"\n"
			"read coor unit 10 card\n"						
			"\n", waterFileName, solventSegName, waterFileName );
	
		sprintf(waterPSFName, "%s.psf", solventSegName );

	
		fprintf(charmmFile, 
		"open write unit 10 card name \"%s.psf\"\n"
		"write psf  unit 10 card\n"
		, solventSegName );
		
		fprintf(charmmFile, "delete atom sele atom * * * end\n" );

		wrote_water_psf = 1;
	
		free(solvent_res_link);
		free(solvent_res_size);
	}

	int wrote_salt = 0;

	if( block->addSalt )
	{	
		printf("Total charge: %lf, %lf protein %lf (inner) %lf (outer) lipid (inner) %lf lipid (outer).\n", total_charge, protein_charge_inner, protein_charge_outer, total_lipid_charge[0], total_lipid_charge[1] );
		// exterior and interior concentrations.

		double nwaters = (water_atom/3); 
		if( activate_martini )
			nwaters = 4 * water_atom;

		double water_vol_A3 = nwaters * 29; // cubic angstroms.
		double water_vol_L = water_vol_A3 * (1e-27);
	
		double water_vol[2]  = { 
			water_vol_L * (rel_vol[0] /(rel_vol[0]+rel_vol[1])),
			water_vol_L * (rel_vol[1] /(rel_vol[0]+rel_vol[1])) };

		double conc[2] = { block->innerKCL, block->outerKCL };

		double total_charge[2] = { total_lipid_charge[0] + protein_charge_inner, total_lipid_charge[1] + protein_charge_outer };

		for( int leaflet = 0; leaflet < 2; leaflet++ )
		{
			// mMole:
			double nKCl_mMole = conc[leaflet] * water_vol[leaflet]; 
			double nKCl = nKCl_mMole * (6.022e20); // atoms per millimole.
		
			nK[leaflet] = nKCl;
			nCl[leaflet] = nKCl;
		
			if( total_charge[leaflet] < 0 )
				nK[leaflet] += lround(fabs(total_charge[leaflet]));
			else
				nCl[leaflet] += lround(fabs(total_charge[leaflet]));
		
			printf("Adding %d K %d Cl to the %s region.\n", nK[leaflet], nCl[leaflet], (leaflet == 0 ? "inner" : "outer") );
		}

		const char *martini_pos = "NA";
		const char *charmm_pos = "POT";
		const char *martini_neg = "CL";
		const char *charmm_neg = "CLA";
	

		const char *pos_seg[] = {"POSI", "POSO"};
		const char *neg_seg[] = {"NEGI", "NEGO" };

		const char *use_pos_res = charmm_pos;
		const char *use_neg_res = charmm_neg;

		if( activate_martini )
		{
			use_pos_res = martini_pos;
			use_neg_res = martini_neg;
		}

		for( int leaflet = 0; leaflet < 2; leaflet++ )
		{
			for( int pass = 0; pass < 2; pass++ )
			{
				int res = 1;	
				if( pass == 0 )
				{
					if( nK[0] + nK[1] > 0 )
					{
						fprintf(charmmFile, "read sequence %s %d\n", use_pos_res, nK[leaflet] );
						fprintf(charmmFile, "generate %s warn\n", pos_seg[leaflet] );
					}
				}
				else
				{
					if( nCl[0] + nCl[1] > 0 )
					{
						fprintf(charmmFile, "read sequence %s %d\n", use_neg_res, nCl[leaflet] );
						fprintf(charmmFile, "generate %s warn\n", neg_seg[leaflet] );
					}
				}
	
				for( int tk = 0; tk < (pass == 0 ? nK[leaflet] : nCl[leaflet]); tk++ )
				{
					int done = 0;
		
					double rp[3];
		
					while(!done)
					{
						rp[0] = -PBC_vec[0][0]/2 + PBC_vec[0][0] * rand()/(double)RAND_MAX;
						rp[1] = -PBC_vec[1][1]/2 + PBC_vec[1][1] * rand()/(double)RAND_MAX;
						rp[2] = -PBC_vec[2][2]/2 + PBC_vec[2][2] * rand()/(double)RAND_MAX; 
						for( int c = 0; c< 3; c++ )
						{
							if( halve[c] )
								rp[c] = -PBC_vec[c][c]/4 + buildData->frac_cen[c] + PBC_vec[c][c]/2 * rand()/(double)RAND_MAX;
						}


						int bad_res = buildData->nclash_aa( rp, 1, 0, ion_cutoff, halve ); 
	
		
						if( !bad_res )
						{
							// is the point inside or outside?

							int f;
							double u, v;
							double distance;
				
							nearPointOnBoxedSurface( rp, &f, &u, &v, M, mlow, mhigh, &distance, 0 );	
							double nearp[3], nearn[3];
				                	evaluateRNRM( f, u, v, nearp, nearn, rsurf );
				
							double dr[3] = { rp[0] - nearp[0], rp[1] - nearp[1], rp[2] - nearp[2] };
							wrapPBC( dr, rsurf+3*nv );
					
							int io = dr[0] * nearn[0] + dr[1] * nearn[1] + dr[2] * nearn[2];
				
							if( io > 0 && leaflet == 0 )
								done = 0;
							else if( io < 0 && leaflet == 1 )
								done = 0;
							else	
								done = 1;
						}
					}
				
					fprintf(charmmFile, "coor set xdir %lf ydir %lf zdir %lf select resid %d end\n",
						rp[0], rp[1], rp[2], res );
					res++;
				}
			
				if( pass == 0 )
				{
					if( nK[leaflet] > 0 )
					{
						fprintf(charmmFile, "write psf card name pot%c.psf\n", (leaflet ? 'o' : 'i'));
						fprintf(charmmFile, "write coor card name pot%c.crd\n", (leaflet ? 'o' : 'i'));
						fprintf(charmmFile, "delete atom sele atom * * * end\n");
					}
				}	
				else
				{
					if( nCl[leaflet] > 0 )
					{
						fprintf(charmmFile, "write psf card name cla%c.psf\n", (leaflet ? 'o' : 'i'));
						fprintf(charmmFile, "write coor card name cla%c.crd\n", (leaflet ? 'o' : 'i'));
						fprintf(charmmFile, "delete atom sele atom * * * end\n");
					}
				}
			}
		}
		wrote_salt = 1;	
	}

	int wrote_psf = 0;

	if( build_mode == CREATE_ADD_COMPLEXES )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", block->system_psf );

		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	

		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", block->system_coords );	

		if( strlen(block->system_coords) > 3 && !strncasecmp(block->system_coords+strlen(block->system_coords)-3, "pdb",3 ) )
			fprintf(charmmFile, "read coor pdb unit 10\n" );	
		else
			fprintf(charmmFile, "read coor card unit 10\n" );	

		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
		
		// delete step

		if( buildData->charmm_delete_buffer[0] != '\0' )
			fprintf(charmmFile, "%s", buildData->charmm_delete_buffer );
	}


	for( int p = 0; p < npairs; p++ )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].PSFfileName );

		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].CRDfileName );	
		fprintf(charmmFile, "read coor card unit 10 resid\n" );	
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
		
	}
	
	// MUST follow lipids, not precede it. The lipids are counting on measuring offsets from their own zero.

	for( int p = 0; p < ncomplex; p++ )
	{
		for( int s = 0; s < nsegs_for_complex[p]; s++ )	
		{	
			char use_segid[256];
			
			if( p < 10 )
				sprintf(use_segid, "p0%d%c", p, 'A'+s );
			else if( p < 100 )
				sprintf(use_segid, "p%d%c", p, 'A'+s );
	
			fprintf(charmmFile, "open unit 10 card read name \"%s.psf\"\n", use_segid );
	
			if( !wrote_psf )
			{
				fprintf(charmmFile, "read psf card unit 10\n" );	
				wrote_psf = 1;
			}
			else
				fprintf(charmmFile, "read psf card append unit 10\n" );	
	
			fprintf(charmmFile, "close unit 10\n" );	
			fprintf(charmmFile, "open unit 10 card read name \"%s.crd\"\n", use_segid);	
			fprintf(charmmFile, "read coor card unit 10 append\n" );	
			fprintf(charmmFile, "close unit 10\n" );
			fprintf(charmmFile, "\n");	
		}
	}

	if( added_pcomplex_ions )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s_extra_ions.psf\"\n", block->jobName );

		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	

		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s_extra_ions.crd\"\n",block->jobName);	
		fprintf(charmmFile, "read coor card unit 10 resid\n" );	
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	


	}

	if( wrote_water_psf )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", waterPSFName );
		if( !wrote_psf )
		{
			fprintf(charmmFile, "read psf card unit 10\n" );	
			wrote_psf = 1;
		}
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", waterFileName );	
		fprintf(charmmFile, "read coor card unit 10 append\n" );
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
			
	}


	if( wrote_salt )
	{
		for( int leaf = 0; leaf < 2; leaf++ )
		{
			char lchar = (leaf ? 'o' : 'i');
			if( nK[leaf] >0)
			{
				fprintf(charmmFile, "open unit 10 card read name pot%c.psf\n", lchar);
				if( !wrote_psf )
				{
					fprintf(charmmFile, "read psf card unit 10\n" );	
					wrote_psf = 1;
				}
				else
					fprintf(charmmFile, "read psf card append unit 10\n" );	
				fprintf(charmmFile, "close unit 10\n" );	
				fprintf(charmmFile, "open unit 10 card read name pot%c.crd\n", lchar );	
				fprintf(charmmFile, "read coor card unit 10 resid\n" );
				fprintf(charmmFile, "close unit 10\n" );
				fprintf(charmmFile, "\n");	
			}
	
			if( nCl[leaf] > 0 )
			{
				fprintf(charmmFile, "open unit 10 card read name cla%c.psf\n", lchar);
				if( !wrote_psf )
				{
					fprintf(charmmFile, "read psf card unit 10\n" );	
					wrote_psf = 1;
				}
				else
					fprintf(charmmFile, "read psf card append unit 10\n" );	
				fprintf(charmmFile, "close unit 10\n" );	
				fprintf(charmmFile, "open unit 10 card read name cla%c.crd\n", lchar );	
				fprintf(charmmFile, "read coor card unit 10 resid\n" );
				fprintf(charmmFile, "close unit 10\n" );
				fprintf(charmmFile, "\n");	
			}
		}
	}
	
	if( block->create_all_atom == CREATE_SYSTEM )
		fprintf(charmmFile, "%s", charmm_footer_build );
	else if( block->create_all_atom == CREATE_ADD_COMPLEXES )
		fprintf(charmmFile, "%s", charmm_footer_add );

	//free(regions_for_face);
	free(rsurf);
	
	fclose(doubleBondIndexes);		
}

// getCoordinateSystem
// 
// We need to have a coordinate system that is transported smoothly from one central location
// We also want to have a robust representation of a lipid far from that location
// These are somewhat incompatible on a complicated surface: the coordinate system becomes non-orthogonal and may have a very different metric.
// This function gets x and y from the principal curvatures at one face (by default)
// it smoothly transports the x coordinate onto the new point
// y is then determined by orthogonality with the normal
// this determines the xyz coordinate system mapping at the distance point where the lipid can be reconstructed.
int surface::getCoordinateSystem( int source_f,   double *source_u,  double *source_v, 
//				  int distance_f, double distant_u, double distant_v, 
				  double dr[3], double strain, int leaflet,
				  double *dx_duv, double *dy_duv, double *rsurf, int *regional_face, int *ncrosses, const double *set_x )
{
	static int cntr=0;
	double drdu[3]={0,0,0}, drdv[3]={0,0,0};	
	double u_cen = *source_u;
	double v_cen = *source_v;

	double transp_cen[3]={0,0,0}, transp_nrm[3]={0,0,1};

	if( source_f >= nf_faces )	
	{
//		printf("Using irregular vertex.\n");
	}

	evaluateRNRM( source_f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	ru( source_f, u_cen, v_cen,  rsurf, drdu ); 
	rv( source_f, u_cen, v_cen,  rsurf, drdv ); 

	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1=0, c2=0;
	double cvec1[2], cvec2[2];

	double k;
	double ctot = c(source_f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);

	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

	double crp[3];
	cross( vec_c1, vec_c2, crp);
	double dp_sign = crp[0] * transp_nrm[0] + crp[1] * transp_nrm[1] + crp[2] * transp_nrm[2];

	double dx[2] = { cvec1[0], cvec1[1] }; 
	double dy[2] = { cvec2[0], cvec2[1] }; 

	if( set_x )
	{
		dx[0] = set_x[0];
		dx[1] = set_x[1];
	
		double vec_x[3] = { drdu[0] * dx[0] + drdv[0] * dx[1],
				    drdu[1] * dx[0] + drdv[1] * dx[1],
				    drdu[2] * dx[0] + drdv[2] * dx[1] };
		double lv = normalize(vec_x);

		// dx is now unit system.
		dx[0] /= lv;
		dx[1] /= lv;
	
		double RuRu = drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2];
		double RuRv = drdu[0]*drdv[0]+drdu[1]*drdv[1]+drdu[2]*drdv[2];
		double RvRv = drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2];
	
		double xu = dx[0];
		double xv = dx[1];
		double yu = 1;
		double yv = (-RuRu * xu * yu - RuRv * xv * yu) / (RuRv * xu + RvRv * xv);

		dy[0] = yu;
		dy[1] = yv;		
		double vec_y[3] = { drdu[0] * dy[0] + drdv[0] * dy[1],
				    drdu[1] * dy[0] + drdv[1] * dy[1],
				    drdu[2] * dy[0] + drdv[2] * dy[1] };
		lv = normalize(vec_y);
	
		dy[0] /= lv;
		dy[1] /= lv;

		// already normalized.
		lv1 = 1;
		lv2 = 1;
		
		double old_c1 = c1;
		double old_c2 = c2;

		double new_vec_c1[3] = {  dx[0] * drdu[0] + dx[1] * drdv[0],
			   		  dx[0] * drdu[1] + dx[1] * drdv[1],
			   		  dx[0] * drdu[2] + dx[1] * drdv[2] };
		
		double new_vec_c2[3] = {  dy[0] * drdu[0] + dy[1] * drdv[0],
			   		  dy[0] * drdu[1] + dy[1] * drdv[1],
			   		  dy[0] * drdu[2] + dy[1] * drdv[2] };

		double l1n = normalize(new_vec_c1);
		double l1o = normalize(vec_c1);
		double l2n = normalize(new_vec_c2);
		double l2o = normalize(vec_c2);

		double dp11 = new_vec_c1[0] * vec_c1[0] + new_vec_c1[1] * vec_c1[1] + new_vec_c1[2] * vec_c1[2];
		double dp12 = new_vec_c1[0] * vec_c2[0] + new_vec_c1[1] * vec_c2[1] + new_vec_c1[2] * vec_c2[2];
		double dp21 = new_vec_c2[0] * vec_c1[0] + new_vec_c2[1] * vec_c1[1] + new_vec_c2[2] * vec_c1[2];
		double dp22 = new_vec_c2[0] * vec_c2[0] + new_vec_c2[1] * vec_c2[1] + new_vec_c2[2] * vec_c2[2];

		c1 = old_c1 * dp11*dp11 + old_c2 * dp12 * dp12;
		c2 = old_c1 * dp21*dp21 + old_c2 * dp22 * dp22;
	} 
	
	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du=0,dv=0;
	double z_scaled = dr[2];	
	
	double use_PP = exp(strain)*PP;
	
	if( leaflet == 1 )
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
//		double scale1 = (1- c1 * (use_PP-dr[2]))/(1+c1*use_PP);
//		double scale2 = (1- c2 * (use_PP-dr[2]))/(1+c2*use_PP);
//		double scale1 = 1./(1+c1*use_PP);
//		double scale2 = 1./(1+c2*use_PP);

		double scale1 = mod_exp(-use_PP * c1);
		double scale2 = mod_exp(-use_PP * c2);

		// if scale1 is less than 1, it means that the z length has shrunk (the x dimension is larger at the midplane and so the particle's midplane displacement must be scaled down).

		double lat_scale = scale1*scale2;

		dc1 *= scale1;
		dc2 *= scale2;

		double z =dr[2]*exp(strain);
		double scale = (1+c1*use_PP) * (1+c2*use_PP);
		z_scaled = scale * use_PP - (use_PP -z) * (1+(use_PP-z)*c1)*(1+(use_PP-z)*c2);
	
		du = dx[0] * dc1 + dy[0] * dc2; 
		dv = dx[1] * dc1 + dy[1] * dc2; 
	}
	else
	{
		//double scale1 = (1+ c1 * (-use_PP-dr[2]))/(1-c1*(-use_PP));
		//double scale2 = (1+ c2 * (-use_PP-dr[2]))/(1-c2*(-use_PP));
//		double scale1 = 1./(1-c1*use_PP);
//		double scale2 = 1./(1-c2*use_PP);
		double scale1 = mod_exp(use_PP * c1);
		double scale2 = mod_exp(use_PP * c2);

		double lat_scale = scale1*scale2;
		dc1 *= scale1;
		dc2 *= scale2;
		//z_scaled = dr[2] * (1+c1*dr[2]) * (1+c2*dr[2]);
		double z =dr[2]*exp(strain);
		double scale = (1-c1*use_PP) * (1-c2*use_PP);
		//z_scaled = -scale * use_PP - (-use_PP -z) * scale1 * scale2;
		z_scaled = -scale * use_PP - (-use_PP -z) * (1-(-use_PP-z)*c1)*(1-(-use_PP-z)*c2);
	
		du = dx[0] * dc1 + dy[0] * dc2; 
		dv = dx[1] * dc1 + dy[1] * dc2; 
	}


	int done = 0;

	int fp = source_f;



	int t_cntr = 0;
	while( ! done )
	{
		int f_pre = source_f;
		double upre = u_cen;
		double vpre = v_cen;
		double du_pre = du;
		double dv_pre = dv;

		int f2 = nextFace( fp, &u_cen, &v_cen, &du, &dv, rsurf, dx );	

		if( regional_face[f2] == 0 )
			(*ncrosses)++;

		if( f2 == fp ) 
			done = 1;

		fp = f2;

		t_cntr++;
	}
	cntr++;
	// dx is the smoothly transported x coordinate.

	// the new drdu/drdv
	ru( fp, u_cen, v_cen,  rsurf, drdu ); 
	rv( fp, u_cen, v_cen,  rsurf, drdv ); 

	double vec_x[3] = { drdu[0] * dx[0] + drdv[0] * dx[1],
			    drdu[1] * dx[0] + drdv[1] * dx[1],
			    drdu[2] * dx[0] + drdv[2] * dx[1] };
	double lv = normalize(vec_x);

	// dx is now unit system.
	dx[0] /= lv;
	dx[1] /= lv;

	double RuRu = drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2];
	double RuRv = drdu[0]*drdv[0]+drdu[1]*drdv[1]+drdu[2]*drdv[2];
	double RvRv = drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2];

	double xu = dx[0];
	double xv = dx[1];
	double yu = 1;
	double yv = 0;

	if( fabs( RuRv * xu + RvRv * xv ) > 1e-4 )
	{
		yu = 1;
		yv = (-RuRu * xu * yu - RuRv * xv * yu) / (RuRv * xu + RvRv * xv);
	}
	else
	{
		yv = 1;
		yu = (-RvRv * xv * yv - RuRv * xu * yv) / (RuRv * xv + RuRu * xu);
	}
		
	// reset dy.
	dy[0] = yu;
	dy[1] = yv;
	
	double vec_y[3] = { drdu[0] * dy[0] + drdv[0] * dy[1],
			    drdu[1] * dy[0] + drdv[1] * dy[1],
			    drdu[2] * dy[0] + drdv[2] * dy[1] };
	lv = normalize(vec_y);

	dy[0] /= lv;
	dy[1] /= lv;

	double final_cen[3];
	double final_nrm[3];

	evaluateRNRM( fp, u_cen, v_cen, final_cen, final_nrm, rsurf ); 
	
	double fcrp[3];
	cross( vec_x, vec_y, fcrp );

	double dp_final = fcrp[0] * final_nrm[0] + fcrp[1] * final_nrm[1] + fcrp[2] * final_nrm[2];

	if( dp_final * dp_sign < 0 )
	{
		dy[0] *= -1;
		dy[1] *= -1;
	}

	dx_duv[0] = dx[0];
	dx_duv[1] = dx[1];

	dy_duv[0] = dy[0];
	dy_duv[1] = dy[1];

	*source_u = u_cen;
	*source_v = v_cen;

	// vec_x = dx[0] * drdu + dx[1] * drdv
	// vec_y is perpendicular 
	return fp;
	

	// x is now d

/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	
}


int surface::simple_evaluate_at( double eval[3], double dr[3], int f, double *u, double *v, double *rsurf, int leaflet, double strain, double *dx_duv, double *dy_duv, double w_use, double w_rim, double *rimp, double *rimn)
{
	double drdu[3]={0,0,0}, drdv[3]={0,0,0};
	
	double u_cen = *u;
	double v_cen = *v;

	double transp_cen[3]={0,0,0}, transp_nrm[3]={0,0,1};

	if( f >= nf_faces )	
	{
//		printf("Using irregular vertex.\n");
	}

	evaluateRNRM( f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	double eval_in[3] = { 
		transp_cen[0] + transp_nrm[0] * dr[2]*exp(strain), 
		transp_cen[1] + transp_nrm[1] * dr[2]*exp(strain), 
		transp_cen[2] + transp_nrm[2] * dr[2]*exp(strain) 
		};
	ru( f, u_cen, v_cen,  rsurf, drdu ); 
	rv( f, u_cen, v_cen,  rsurf, drdv ); 
	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1=0, c2=0;
	double cvec1[2], cvec2[2];

	double k;
	double ctot = c(f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);


	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

	if( dx_duv && dy_duv )
	{
		// replace with these vectors.
	
		cvec1[0] = dx_duv[0];
		cvec1[1] = dx_duv[1];
	
		cvec2[0] = dy_duv[0];
		cvec2[1] = dy_duv[1];

		double old_c1 = c1;
		double old_c2 = c2;

		double new_vec_c1[3] = {  cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			   		  cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			   		  cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
		
		double new_vec_c2[3] = {  cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			   		  cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			   		  cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };

		double l1n = normalize(new_vec_c1);
		double l1o = normalize(vec_c1);
		double l2n = normalize(new_vec_c2);
		double l2o = normalize(vec_c2);

		double dp11 = new_vec_c1[0] * vec_c1[0] + new_vec_c1[1] * vec_c1[1] + new_vec_c1[2] * vec_c1[2];
		double dp12 = new_vec_c1[0] * vec_c2[0] + new_vec_c1[1] * vec_c2[1] + new_vec_c1[2] * vec_c2[2];
		double dp21 = new_vec_c2[0] * vec_c1[0] + new_vec_c2[1] * vec_c1[1] + new_vec_c2[2] * vec_c1[2];
		double dp22 = new_vec_c2[0] * vec_c2[0] + new_vec_c2[1] * vec_c2[1] + new_vec_c2[2] * vec_c2[2];

		c1 = old_c1 * dp11*dp11 + old_c2 * dp12 * dp12;
		c2 = old_c1 * dp21*dp21 + old_c2 * dp22 * dp22;

//		c1 = dp11 * old_c1/l1n/l1o + dp12 * old_c2/l1n/l2o;
//		c2 = dp21 * old_c1/l2n/l1o + dp22 * old_c2/l2n/l2o;

		lv1 = l1n;
		lv2 = l2n;	
	}


/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	// only modification is z?

	double total_c = c1+c2;

	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du=0,dv=0;
	double z_scaled = dr[2];	

	double x_dir[3] = { 
		cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
		cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
		cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	
	double y_dir[3] = { 
		cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
		cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
		cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
/*
	if( f == nf_faces )
	{
		printf("x: %le %le %le ", x_dir[0], x_dir[1], x_dir[2] );
		printf("y: %le %le %le\n", y_dir[0], y_dir[1], y_dir[2] );
	}
*/
	double use_PP = exp(strain)*PP;

	double lat_scale = 1.0;

	if( total_c < -0.03 ) total_c = -0.03;
	if( total_c >  0.03 ) total_c = 0.03;

	if( leaflet == 1 )
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		//lat_scale =  (1- total_c * (use_PP-dr[2]))/(1+total_c*use_PP);
//		lat_scale = mod_exp( -total_c * (use_PP-dr[2]) ); // z  is zero leads to contraction of the outer leaflet, pos curv
		
		double z = dr[2];
		// this is code for the upper leaflet. 
		// If we have positive curvature, lipids should be squeezed in laterally at the midplane (lat_scale < 0)
		lat_scale = mod_exp( -total_c * (use_PP-z) );
		z_scaled = z * mod_exp( -total_c * (z/2-use_PP) );
	}
	else
	{
		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		//lat_scale =  (1+ total_c * (use_PP+dr[2]))/(1-total_c*use_PP);
		double z = dr[2];
		lat_scale = mod_exp( total_c * (use_PP+z) );
		z_scaled = z * mod_exp( total_c * (-z/2-use_PP) );
	}

	if( rimp && w_use < 1.0 )
	{
		double usen[3] = { 
//			np[0] * w_use + rimn[0] * w_rim,
//			np[1] * w_use + rimn[1] * w_rim,
//			np[2] * w_use + rimn[2] * w_rim	
			transp_nrm[0], transp_nrm[1], transp_nrm[2] };
		normalize(usen);
		eval[0] = transp_cen[0]+rimp[0] + usen[0] * z_scaled + (x_dir[0] * dr[0] + y_dir[0] * dr[1])*lat_scale; 
		eval[1] = transp_cen[1]+rimp[1] + usen[1] * z_scaled + (x_dir[1] * dr[0] + y_dir[1] * dr[1])*lat_scale; 
		eval[2] = transp_cen[2]+rimp[2] + usen[2] * z_scaled + (x_dir[2] * dr[0] + y_dir[2] * dr[1])*lat_scale; 
	}
	else
	{
		eval[0] = transp_cen[0] + transp_nrm[0] * z_scaled + (x_dir[0] * dr[0] + y_dir[0] * dr[1])*lat_scale; 
		eval[1] = transp_cen[1] + transp_nrm[1] * z_scaled + (x_dir[1] * dr[0] + y_dir[1] * dr[1])*lat_scale; 
		eval[2] = transp_cen[2] + transp_nrm[2] * z_scaled + (x_dir[2] * dr[0] + y_dir[2] * dr[1])*lat_scale; 
	}

	double dr_out[3] = { eval[0] - eval_in[0], eval[1] - eval_in[1], eval[2] - eval_in[2] };
	double rout = normalize(dr_out);
	double rin = sqrt(dr[0]*dr[0]+dr[1]*dr[1]);

//	printf("%lf c1: %lf c2: %lf out_len %lf orig len %lf\n", dr[2], c1, c2, rout, rin); 					

	*u = u_cen;
	*v = v_cen;

	return f;
}


	
void EndSegment( FILE *charmmFile, char *cur_filename, char *cur_segment, char *cur_segname, crd_psf_pair **pairs, int *seg_cntr, int *npairs, int *npair_space, int x_leaflet,
	int *cur_size, int *cur_natoms, int *cur_atom, int *cur_res, int *switched, int gm1_switch )
{	
	const char *out_in[3]= {"IN","OUT", "RIM"};

        fprintf(charmmFile, 
        "\n" 
        "open read card unit 10 name \"%s\"\n"
        "read sequence coor card unit 10\n"
        "generate %s setup warn first none last none\n"
        "open read unit 10 card name \"%s\"\n"
        "read coor unit 10 card resid\n", cur_filename, cur_segname, cur_filename );
     
        if( gm1_switch == 1 ) // GM1
        {    
                fprintf(charmmFile, "patch CERB %s %d %s %d setup warn\n", cur_segname, 2, cur_segname, 1 ); 
                fprintf(charmmFile, "patch 14BB %s %d %s %d setup warn\n",  cur_segname,2,  cur_segname,3 );
                fprintf(charmmFile, "patch 14BA %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,4 );
                fprintf(charmmFile, "patch 13BB %s %d %s %d setup warn\n",  cur_segname,4,  cur_segname,5 );
                fprintf(charmmFile, "patch SA23AB %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,6 );
        }    
        else if( gm1_switch == 3 ) // GM3
        {    
                fprintf(charmmFile, "patch CERB %s %d %s %d setup warn\n", cur_segname, 2, cur_segname, 1 ); 
                fprintf(charmmFile, "patch 14BB %s %d %s %d setup warn\n",  cur_segname,2,  cur_segname,3 );
                fprintf(charmmFile, "patch SA23AB %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname, 4 );
        }    

        fprintf(charmmFile,     "\n" 
        "open write unit 10 card name \"%s.psf\"\n"
        "write psf  unit 10 card\n"
        "delete atom sele atom * * * end\n",
         cur_segname );

	FILE *crdFile = fopen( cur_filename, "w");
	printCRDHeader( crdFile, *cur_natoms );
	fprintf(crdFile, "%s", cur_segment );
	fclose(crdFile);

	if( *npairs == *npair_space )
	{
		*npair_space *= 2;

		*pairs = (crd_psf_pair *)realloc( *pairs, sizeof(crd_psf_pair) * *npair_space );
	}

	strcpy( (*pairs)[*npairs].CRDfileName, cur_filename );
	char psf_file[256];
	sprintf(psf_file, "%s.psf", cur_segname );
	strcpy( (*pairs)[*npairs].PSFfileName, psf_file ); 

	(*npairs)++;
	
	(*seg_cntr)++;		
		
	sprintf(cur_filename, "segment_%s%d.crd", out_in[x_leaflet], *seg_cntr );
	sprintf(cur_segname, "%s%d", out_in[x_leaflet], *seg_cntr ); 


	*cur_size = 0;
	*cur_natoms = 0;
	(cur_segment)[0] = '\0';
	*cur_atom = 1;
	*cur_res  = 1;
	*switched=0;
}

double mod_exp( double val )
{
	if( val > 0 )
		return 1 + val;
	else	
		return exp(val);	
}

	
int TestAdd( surface *theSurface, int l, int *lipid_start, int *lipid_stop, struct atom_rec *at, 
	double *cell_shift, double *upper_cen, double *add_to,
	double alpha,
	double main_u_cen,
	double main_v_cen,
	double *use_r, double *source_r,
	double spot_u, double spot_v,
	int fout,
	double *rsurf,
	int leaflet,
	double strain,
	double *dx_uv,
	double *dy_uv,	
	double w_use,
	double w_rim,
	double *rimp,
	double *rimn,
	int x_leaflet,
	double *total_lipid_charge,
	int *cur_atom,
	int *cur_natoms,
	char *cur_segname,
	char **cur_segment,
	int *cur_size,
	int *cur_space,
	int *cur_res,
	aa_build_data *buildData,
	int **local_cycles,
	int *local_cycle_len,
	int local_ncycles,

	int *local_bonds,
	int *local_nbonds,
	int *local_bond_offsets,
	FILE *doubleBondIndexes,
	int is_mod // was this modified by a complex to add a protein here?
	)
{	
	int pres = at[lipid_start[l]].res;
	
	double wrap_to[3] = {0,0,0};

	double *coords = (double *)malloc( sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	double *o_coords = (double *)malloc( sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	
	double r_pt[3], r_nrm[3];
	theSurface->evaluateRNRM( fout, spot_u, spot_v, r_pt, r_nrm, rsurf );


	int toff = 0;
	for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++, toff++ )
	{
		double dx = alpha*(at[xa].x-upper_cen[0]+cell_shift[0]);
		double dy = alpha*(at[xa].y-upper_cen[1]+cell_shift[1]);
	
		double use_r[3] = { dx, dy, at[xa].z };
		double eval[3];
	
		double transp_u = main_u_cen;
		double transp_v = main_v_cen;
		
	
		double m1_r[3] = { use_r[0] - source_r[0], use_r[1] - source_r[1], use_r[2] };
		double local_u = spot_u, local_v = spot_v;


		theSurface->simple_evaluate_at( eval, m1_r, fout, &local_u, &local_v, rsurf, leaflet, strain, dx_uv, dy_uv, w_use, w_rim, rimp, rimn );

		double tc[3] = { eval[0], eval[1], eval[2] };

		if( xa > lipid_start[l] )
		{
			double dr[3] = { tc[0] - wrap_to[0], tc[1] - wrap_to[1], tc[2] - wrap_to[2] };
			theSurface->wrapPBC( dr, rsurf+3*theSurface->nv );
	
			tc[0] = wrap_to[0] + dr[0];
			tc[1] = wrap_to[1] + dr[1];
			tc[2] = wrap_to[2] + dr[2];
		}
		else
		{
			wrap_to[0] = tc[0];
			wrap_to[1] = tc[1];
			wrap_to[2] = tc[2];
		}
	
		coords[3*toff+0] = tc[0];	
		coords[3*toff+1] = tc[1];	
		coords[3*toff+2] = tc[2];	
	}
	
	int clash = 0;
	int nclash_iters = 20;	

	memcpy( o_coords, coords,  sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );
	
	double PBC_vec[3][3];
	for( int c1=0;c1<3;c1++)
	for( int c2=0;c2<3;c2++)
		PBC_vec[c1][c2] = theSurface->PBC_vec[c1][c2];

	for( int clash_iter = 0; clash_iter < nclash_iters; clash_iter++ )
	{
		memcpy( coords, o_coords,  sizeof(double) * ( lipid_stop[l] - lipid_start[l]+1) * 3 );

		double jmag = 1.5;

		if( clash_iter == 0 ) jmag = 0;


		double jiggle[3] = { 
			jmag * 2 * (rand()/(double)RAND_MAX-0.5),
			jmag * 2 * (rand()/(double)RAND_MAX-0.5),
			jmag * 2 * (rand()/(double)RAND_MAX-0.5) };

		double dphi = clash_iter * 2*M_PI / nclash_iters;
		
		rotateArbitrary( coords, r_nrm, r_pt, ( lipid_stop[l] - lipid_start[l]+1), dphi );

		int lc = ( lipid_stop[l] - lipid_start[l]+1);

		for( int t = 0; t < ( lipid_stop[l] - lipid_start[l]+1); t++ )
		{
			coords[3*t+0] += jiggle[0];
			coords[3*t+1] += jiggle[1];
			coords[3*t+2] += jiggle[2];
		}
	
		clash = 0;

		int nclash = 0;

		double clash_cutoff = 0.5;

		if( activate_martini )
			clash_cutoff = 3.0;

		nclash = buildData->nclash_aa( coords, lc, is_mod, clash_cutoff ); 

		if( activate_martini ? nclash > 1 : nclash > 10 )
			clash = 1;

		if( clash ) continue;

		// now check local rings against global bonds.	

		int cycle_clash_compare = 0;

		for( int c = 0; c < local_ncycles && !clash; c++ )
		{
			int relev = 1;
	
			for( int xc = 0; xc < local_cycle_len[c]; xc++ )
			{
				if( local_cycles[c][xc] < lipid_start[l] || local_cycles[c][xc] > lipid_stop[l] )
					relev = 0; 
			}
	
			if( relev )
			{
				if( buildData->cycleClash( coords, lipid_start[l], local_cycles[c], local_cycle_len[c] ) )
					cycle_clash_compare = 1;
			}
		}

		clash = cycle_clash_compare;

		// SECOND: check global rings against local bonds.
		// can ring box this if it makes sense.	

		if( ! clash )
		{
			int the_cycle = 0;
			int the_bond_xa = 0;
			int the_sub_bond = 0;
			int got_miss = 0;

			for( int xa = lipid_start[l]; xa <= lipid_stop[l] && !clash; xa++, toff++ )
			{
				int loff = xa - lipid_start[l];
				for( int bx = 0; bx < local_nbonds[xa] && !clash; bx++ )
				{
					int loff2 = local_bonds[local_bond_offsets[xa]+bx] - lipid_start[l];
			
					double r1[3] = { 
						coords[3*loff+0],
						coords[3*loff+1],
						coords[3*loff+2] };
					double r2[3] = { 
						coords[3*loff2+0],
						coords[3*loff2+1],
						coords[3*loff2+2]  };
	
					if( buildData->bondClash( r1, r2 ) )
						clash = 2;
				}
			}	
		}

		if( !clash ) 
		{
#ifdef DEBUG_PRINT
			if( clash_iter > 0 )
				printf("Clashed but resolved on iteration %d (%d).\n", clash_iter, clash );
#endif
			break;
		}
	}	

	if( clash ) 
	{
#ifdef DEBUG_PRINT
		printf("Unresolved clash (%d).\n", clash);
#endif
		free(coords);
		free(o_coords);
		return 0;
	}
	// passes:

	int placed_off = buildData->curPlace();;
			
	buildData->addBondsInRun( placed_off, lipid_start[l], lipid_stop[l]+1, local_bonds, local_bond_offsets, local_nbonds ); 
	buildData->addCyclesInRun( placed_off, coords, lipid_start[l], lipid_stop[l]+1, local_cycles, local_cycle_len, local_ncycles );

	toff = 0;	
	for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++, toff++ )
	{
		if( at[xa].res != pres )
			(*cur_res)++; 
		pres = at[xa].res;

		int at_save = at[xa].bead;
		int res_save = at[xa].res;
		double xsave = at[xa].x;
		double ysave = at[xa].y;
		double zsave = at[xa].z;

		at[xa].x = coords[3*toff+0];
		at[xa].y = coords[3*toff+1];
		at[xa].z = coords[3*toff+2];
	
		at[xa].bead = *cur_atom;
		at[xa].res  = *cur_res;
		at[xa].segRes = *cur_res;

		char temp_segid[256];
		sprintf(temp_segid, "MEMB");
		char *tmp = at[xa].segid;
		at[xa].segid = cur_segname;
	
		if( *cur_size + 1024 > *cur_space )
		{	
			*cur_space += 1024;
			(*cur_segment) = (char *)realloc( (*cur_segment), sizeof(char) * (*cur_space)  );
		}

		printSingleCRD( *cur_segment+*cur_size, at+xa );

		double rxy = sqrt(at[xa].x*at[xa].x+at[xa].y*at[xa].y);
		
		(*cur_size) += strlen(*cur_segment+*cur_size);

		
		double to_add[3] = { at[xa].x, at[xa].y, at[xa].z };
		int placed_at = buildData->addAtom( to_add );
		
		(*cur_natoms)++;
		at[xa].segid = tmp;
		at[xa].bead = at_save;
		at[xa].res = res_save;
	
		at[xa].x = xsave;
		at[xa].y = ysave;
		at[xa].z = zsave;
	
		(*cur_atom)++;
		total_lipid_charge[x_leaflet] += at[xa].charge;	

	}

	buildData->addCrossedBonds( placed_off, placed_off + lipid_stop[l] - lipid_start[l] +1 );

	// add likely cis-double bonds to index file
	
	for( int xl = lipid_start[l]; xl <= lipid_stop[l]; xl++ )
	{
		int loff1 = xl;
		if( at[loff1].atname[0] != 'C' ) continue;

		if( local_nbonds[xl] != 3 ) continue;

		int has_h = 0;

		for( int bx = 0; bx < local_nbonds[xl]; bx++ )
		{
			int b2 = local_bonds[local_bond_offsets[xl]+bx];
			int loff2 = b2;
			if( at[loff2].atname[0] == 'H' ) {has_h=1;}
		}
		if( !has_h ) continue;
		for( int bx = 0; bx < local_nbonds[xl]; bx++ )
		{
			int b2 = local_bonds[local_bond_offsets[xl]+bx];
			int loff2 = b2;
			if( at[loff2].atname[0] != 'C' ) continue;

			if( local_nbonds[b2] != 3 ) continue;
		
			has_h = 0;

			for( int by2 = 0; by2 < local_nbonds[b2]; by2++ )
			{
				int b4 = local_bonds[local_bond_offsets[b2]+by2];
				if( b4 == xl ) continue;
				int loff4 = b4;
				if( at[loff4].atname[0] == 'H' ) has_h = 1;
			}

			if( !has_h ) continue;

			for( int bx2 = 0; bx2 < local_nbonds[xl]; bx2++ )
			{
				int b3 = local_bonds[local_bond_offsets[xl]+bx2];

				if( b3 == b2 ) continue;
				int loff3 = b3;
				if( at[loff3].atname[0] != 'C' ) continue;
			
				for( int by2 = 0; by2 < local_nbonds[b2]; by2++ )
				{
					int b4 = local_bonds[local_bond_offsets[b2]+by2];
					if( b4 == xl ) continue;
					int loff4 = b4;
					if( at[loff4].atname[0] != 'C' ) continue;

					int b3x = b3 - lipid_start[l];
					int xlx = xl - lipid_start[l];
					int b2x = b2 - lipid_start[l];
					int b4x = b4 - lipid_start[l];

					double r4[12] =
					{
						coords[3*b3x+0], coords[3*b3x+1], coords[3*b3x+2],
						coords[3*xlx+0], coords[3*xlx+1], coords[3*xlx+2],
						coords[3*b2x+0], coords[3*b2x+1], coords[3*b2x+2],
						coords[3*b4x+0], coords[3*b4x+1], coords[3*b4x+2]
					};

//					double phi = (180/M_PI)*dihe(r4+0,r4+3,r4+6,r4+9);

//					if( fabs(phi) < 60.0 )
					if( 	strlen(at[loff4].atname) > 1 && strlen(at[loff1].atname) > 1 &&
						 at[loff1].atname[strlen(at[loff1].atname)-1] == 'S' &&
						 at[loff2].atname[strlen(at[loff1].atname)-1] == 'S' &&
						 at[loff3].atname[strlen(at[loff1].atname)-1] == 'S' &&
						 at[loff4].atname[strlen(at[loff1].atname)-1] == 'S' &&
						 ( at[loff4].atname[1] == '3' || at[loff1].atname[1] == '3') )
					{
						fprintf(doubleBondIndexes, "DIHEDRAL %d %d %d %d 500 180.0\n", placed_off + b3x - buildData->getPcut(), 
													     placed_off + xlx - buildData->getPcut(), 
													     placed_off + b2x - buildData->getPcut(), 
													     placed_off + b4x - buildData->getPcut()  );	
					}
					else
					{
						fprintf(doubleBondIndexes, "DIHEDRAL %d %d %d %d 500 0.0\n", placed_off + b3x - buildData->getPcut(), 
													     placed_off + xlx - buildData->getPcut(), 
													     placed_off + b2x - buildData->getPcut(), 
													     placed_off + b4x - buildData->getPcut()  );	
					}
				}
			}
			
		}
	}	


	free(coords);
	free(o_coords);
	return 1;
}
						
#if 1	
void surface::buildLipids( parameterBlock *block, double *rsurf, 
		aa_build_data *buildData, int halve[3],  FILE *charmmFile, FILE *doubleBondIndexes, 
crd_psf_pair **pairs,  int *npairs, int *npair_space, double total_lipid_charge[3],
	surface_mask *upper_leaflet_mask, surface_mask *lower_leaflet_mask, int pass_pool_id[3], int do_leaflet[3], double rim_center[3], double *rim_extent_upper, double *rim_extent_lower )
{

	int cur_size = 0;
	int cur_space = 1024;
	char *cur_segment = (char *)malloc( sizeof(char) * cur_space );
	cur_segment[0] = '\0';
	char *cur_filename = (char *)malloc( sizeof(char) * 1024 );
	char *cur_segname = (char *)malloc( sizeof(char) * 1024 );	
	int cur_natoms = 0;
	int cur_atom = 1;
	int cur_res  = 1;
	int seg_cntr = 1;
	double zero_vec[3] = {0,0,0};

	// these masks have blobs of faces where contiguous bits of simulated bilayers are built in.	
	double target_area_upper;
	double target_area_lower;
	double cur_area,area0;
	double JZ =0;
	double KZ =0;
	double Z = 0;
	double PP_in,PP_out,area_outside,area_inside;
	
	target_area_lower = getPool(pass_pool_id[1])->Lx *  getPool(pass_pool_id[1])->Ly / 4;
	target_area_upper = getPool(pass_pool_id[0])->Lx *  getPool(pass_pool_id[0])->Ly / 4;

	area(rsurf,-1, &cur_area,&area0);

	// Expected TOTAL neutral surface area.		
	// A0*(1 + J * PP + K * PP * PP ) 

	for( int f = 0; f < nt; f++ )
	{
		double u_cen=1.0/3.0;
		double v_cen=1.0/3.0;

		double cvec1[2] = {0,0}, cvec2[2]={0,0};
		double gv = g(f, 1.0/3.0, 1.0/3.0, rsurf );
		double c1=0,c2=0;
		double k;
		double ctot = c(f,u_cen,v_cen,rsurf,&k,cvec1,cvec2,&c1,&c2);
		
		JZ += (c1+c2)*gv;
		KZ += c1*c2 * gv;
	        Z  += gv;
	}

	JZ /= Z;
	KZ /= Z;

	PP_in   = (1-JZ*PP)*PP * exp(-block->strainInner);
	PP_out  = (1+JZ*PP)*PP * exp(-block->strainOuter);

	area_outside = area0;
	area_inside = area0;
	
	int rim_sense = 1; // rim corresponds to the negative of the normal (the "inside")
	
	int nrim = 0;
	double *rimt = NULL;
	rim_center[0] =0;
	rim_center[1] =0;
	rim_center[2] =0;
	// load in icosahedrae, subdivide once, scale to fit.
	surface *upper_rim_patch = NULL;
	surface *lower_rim_patch = NULL;
	double *upper_patch_r = NULL;
	double *lower_patch_r = NULL;
	double dz_rim = 20.0;
	
	double rimAreaAdd = 0;
	double rimAreaSub = 0;

	if( block->do_rim )
	{
		if( do_leaflet[2] <= 0 )
		{
			printf("ERROR. need to supply altPatchPDB.\n");
			exit(1);
		}	

/*
		// center the rim patches above the middle of the rim.
*/
		nrim = 20;
		int *f_ring = (int *)malloc( sizeof(int) * nrim );
		double *uv_ring = (double *)malloc( sizeof(double) * nrim * 2 );
		double *rim_pts = (double *)malloc( sizeof(double) * nrim * 3 );
		int nrim_out;
		double cen[3]={0,0,0};
		get_cut_points( 2, 0, f_ring, uv_ring, rim_pts, nrim, rsurf, &nrim_out, cen, 0, 0  );
		nrim = nrim_out;

		// we want to form a rim from the surface that points into our circle.	
		// do we need to reverse the sense? if the normal points inwards, then we need to.

		double nrm_at_rim[3];	
		double p_at_rim[3];
		evaluateRNRM( f_ring[0], uv_ring[0], uv_ring[1], p_at_rim, nrm_at_rim, rsurf );

		double dp = p_at_rim[0] * nrm_at_rim[0] + p_at_rim[1] * nrm_at_rim[1] + p_at_rim[2] * nrm_at_rim[2];
		if( dp < 0 )
		{
			// normal is pointing in.
			rim_sense *= -1;
			printf("Flipping rim sense. REMOVE THIS PRINT.\n");
		}

		for( int t = 0; t < nrim; t++ )
		{
			rim_center[0] += rim_pts[3*t+0];	
			rim_center[1] += rim_pts[3*t+1];	
			rim_center[2] += rim_pts[3*t+2];	
		}

		rim_center[0] /= nrim*3;
		rim_center[1] /= nrim*3;
		rim_center[2] /= nrim*3;




		// get patch cuts for upper and lower.

		int nuse_cut = 20;
		int nuse_cut1, nuse_cut2;
		int *f_upper = (int *)malloc( sizeof(int) * nuse_cut );
		double *uv_upper = (double *)malloc( sizeof(double) * nuse_cut*2);
		double *r_cut_upper = (double *)malloc( sizeof(double) * nuse_cut * 3 );
		
		int *f_lower = (int *)malloc( sizeof(int) * nuse_cut );
		double *uv_lower = (double *)malloc( sizeof(double) * nuse_cut*2);
		double *r_cut_lower = (double *)malloc( sizeof(double) * nuse_cut * 3 );
		get_cut_points( 2 /* z */, dz_rim, f_upper, uv_upper, r_cut_upper, nuse_cut, rsurf, &nuse_cut1, cen, 0, 0 );
		get_cut_points( 2 /* z */, -dz_rim, f_lower, uv_lower, r_cut_lower, nuse_cut, rsurf, &nuse_cut2, cen, 0, 0 );
		

		for( int t = 0; t < nrim; t++ )
		{
			double dr[3] = { r_cut_upper[3*t+0] - rim_center[0],
					 r_cut_upper[3*t+1] - rim_center[1],
					 0 };
			double r = normalize(dr);

			*rim_extent_upper += r;
			
			double drl[3] = { r_cut_lower[3*t+0] - rim_center[0],
					 r_cut_lower[3*t+1] - rim_center[1],
					 0 };
			r = normalize(drl);

			*rim_extent_lower += r;
		}

		*rim_extent_upper /= (nrim); 
		*rim_extent_lower /= (nrim); 


		upper_rim_patch = getAuxSphere( 1 ); 
		lower_rim_patch = getAuxSphere( 1 ); 

		upper_patch_r = (double *)malloc( sizeof(double) * (3*upper_rim_patch->nv+3) );
		lower_patch_r = (double *)malloc( sizeof(double) * (3*lower_rim_patch->nv+3) );
		upper_patch_r[3*upper_rim_patch->nv+0]=1.0;
		upper_patch_r[3*upper_rim_patch->nv+1]=1.0;
		upper_patch_r[3*upper_rim_patch->nv+2]=1.0;
		lower_patch_r[3*lower_rim_patch->nv+0]=1.0;
		lower_patch_r[3*lower_rim_patch->nv+1]=1.0;
		lower_patch_r[3*lower_rim_patch->nv+2]=1.0;
		upper_rim_patch->get(upper_patch_r);
		lower_rim_patch->get(lower_patch_r);

		double rpt[3], npt[3];
		upper_rim_patch->evaluateRNRM( 0, 1.0/3.0, 1.0/3.0, rpt, npt, upper_patch_r );
	
		double ndp = rpt[0]*npt[0] + rpt[1] * npt[1] + rpt[2] * npt[2];
	
		if( ndp < 0 )
		{
			printf("Inverting aux spheres.\n");
			for( int i = 0; i < upper_rim_patch->nv; i++ )
			{	
				upper_patch_r[3*i+0] *= -1;
				upper_patch_r[3*i+1] *= -1;
				upper_patch_r[3*i+2] *= -1;
			}
			
			for( int i = 0; i < lower_rim_patch->nv; i++ )
			{	
				lower_patch_r[3*i+0] *= -1;
				lower_patch_r[3*i+1] *= -1;
				lower_patch_r[3*i+2] *= -1;
			}
		}

		double R_approx = sqrt(rpt[0]*rpt[0]+rpt[1]*rpt[1]+rpt[2]*rpt[2]);

		double scale = *rim_extent_upper/R_approx;

		for( int i = 0; i < upper_rim_patch->nv; i++ )
		{
			upper_patch_r[3*i+0] *= scale;
			upper_patch_r[3*i+1] *= scale;
			upper_patch_r[3*i+2] *= scale * (dz_rim / *rim_extent_upper );
			
			upper_patch_r[3*i+0] += rim_center[0];
			upper_patch_r[3*i+1] += rim_center[1];
			upper_patch_r[3*i+2] += rim_center[2];

			upper_patch_r[3*i+2] += dz_rim;
		}
		
		scale = *rim_extent_lower/R_approx;	

		for( int i = 0; i < lower_rim_patch->nv; i++ )
		{
			lower_patch_r[3*i+0] *= scale;
			lower_patch_r[3*i+1] *= scale;
			lower_patch_r[3*i+2] *= scale * (dz_rim/ *rim_extent_lower);

			lower_patch_r[3*i+0] += rim_center[0];
			lower_patch_r[3*i+1] += rim_center[1];
			lower_patch_r[3*i+2] += rim_center[2];

			lower_patch_r[3*i+2] -= dz_rim;
		}

		upper_rim_patch->put(upper_patch_r);
		lower_rim_patch->put(lower_patch_r);

		upper_rim_patch->addFixedPoint( rim_center );
		lower_rim_patch->addFixedPoint( rim_center );
		
		for( int t = 0; t < nuse_cut1; t++ )
			upper_rim_patch->addFixedPoint( r_cut_upper+3*t );
		for( int t = 0; t < nuse_cut2; t++ )
			lower_rim_patch->addFixedPoint( r_cut_lower+3*t );

		// subtract out the cylindrical section:
		rimAreaSub = R_approx * 2*M_PI * 2 * dz_rim;
		// add in the two portions of the sphere.
		rimAreaAdd = 2 * 4*M_PI * (R_approx - 0.5 * dz_rim) * (dz_rim);


		free(f_upper);
		free(f_lower);
		free(uv_upper);
		free(r_cut_upper);
		free(r_cut_lower);
		free(uv_lower);

//		free(upper_patch_r);
//		free(lower_patch_r);
	}
	// get regions of the bilayer which we will map collectively attempting to leave a minimum of seams.

	// Eventually I'd like to place lipids with as few seams,
	// and as little lateral tension inhomogeneity as possible.
	// for now I'll just put them on the faces.

	if( rim_sense > 0 )
		area_inside += rimAreaAdd + rimAreaSub;
	else
		area_outside += rimAreaAdd + rimAreaSub;

	double area_target_outside = area_outside * (1 + JZ * PP_out + KZ * PP * PP )* exp(-0.5*block->strainOuter);
	double area_target_inside  = area_inside * (1 - JZ * PP_in + KZ * PP * PP )*exp(-0.5*block->strainInner);

	buildData->frac_cen[0]=0;
	buildData->frac_cen[1]=0;
	buildData->frac_cen[2]=0;

	for( int c = 0; c < 3; c++ )
	{
		if( halve[c] )
		{
			area_target_outside *= 0.5;
			area_target_inside *= 0.5;
		}
	}

	printf("Area-midplane: %le Area_NS/PP_outside: %le\n", area0, area_target_outside );
	printf("Area-midplane: %le Area_NS/PP_inside:  %le\n", area0, area_target_inside  );

	double area_fraction_outside = 1.0;
	double area_fraction_inside = 1.0;
	int seed = rand();
	
	double APL[4] = {0,0,0,0};
	int n_build_passes = 2;

	int patch_warning = 0;

	if( block->do_rim )
		n_build_passes += 2;
	
	build_pass passes[n_build_passes];
	
	for( int l = 0; l < 2; l++ )
	{
		passes[l].structure_take_from = l; // simple
		for ( int c = 0; c < 3; c++ )
		{
			passes[l].min_cut[c] = 1e30; // no limit, exclude above
			passes[l].max_cut[c] = -1e30; // no limit, exclude below
		}

		passes[l].useSurface = this;
		passes[l].rsurf = rsurf;

		if( l == 1 )
			passes[l].theMask = upper_leaflet_mask; 
		else
			passes[l].theMask = lower_leaflet_mask; 
		passes[l].strain = ( l == 0 ? block->strainInner : block->strainOuter );
		passes[l].orientation = ( l == 0 ? -1 : 1 );
	}
	
	surface_mask rim_mask_upper;
	surface_mask rim_mask_lower;

	if( block->do_rim )
	{
		if( pass_pool_id[2] < 0 )	
		{
			printf("Need altPatchPDB set to build hemifusion structure.\n");
			exit(1);
		}

		rim_mask_upper.build( upper_rim_patch, upper_patch_r, getPool(pass_pool_id[2])->Lx * getPool(pass_pool_id[2])->Ly / 4 ); 
		rim_mask_lower.build( lower_rim_patch, lower_patch_r, getPool(pass_pool_id[2])->Lx * getPool(pass_pool_id[2])->Ly / 4 ); 

		for( int l = 2; l < 4; l++ )
		{
			passes[l].structure_take_from = 2; // this is where the "aux" structure is.

			for ( int c = 0; c < 3; c++ )
			{
				passes[l].min_cut[c] = 1e30; // exclude above
				passes[l].max_cut[c] = -1e30; // exclude below
			}

			passes[l].useSurface = ( l == 2 ? lower_rim_patch : upper_rim_patch);
			passes[l].strain = block->strainInner;
			passes[l].rsurf = ( l == 2 ? lower_patch_r : upper_patch_r );
			passes[l].orientation = -1; // always use the inside of our spheres for the rims.
	
			// get regions for rims.
		
			if( l == 2 ) 
				passes[l].theMask = &rim_mask_lower; 
			else
				passes[l].theMask = &rim_mask_upper; 
		}		
			
		// now, the spatial constraints on where to use which surface.
		if( rim_sense > 0 )
		{
			// remove from the leaflet on the side opposite the normal.
			
			passes[0].min_cut[0] = -1e30; // infinite in xy
			passes[0].max_cut[0] = 1e30;
			passes[0].min_cut[1] = -1e30;
			passes[0].max_cut[1] = 1e30;
			passes[0].min_cut[2] = rim_center[2] - dz_rim;
			passes[0].max_cut[2] = rim_center[2] + dz_rim;
		}
		else
		{
			// remove from the leaflet on the side with the normal.
			passes[1].min_cut[0] = -1e30; // infinite in xy
			passes[1].max_cut[0] = 1e30;
			passes[1].min_cut[1] = -1e30;
			passes[1].max_cut[1] = 1e30;
			passes[1].min_cut[2] = rim_center[2] - dz_rim;
			passes[1].max_cut[2] = rim_center[2] + dz_rim;
		}
		// lower rim.
		passes[2].min_cut[0] = -1e30; // infinite in xy
		passes[2].max_cut[0] = 1e30;
		passes[2].min_cut[1] = -1e30;
		passes[2].max_cut[1] = 1e30;
		passes[2].min_cut[2] = -1e30;
		passes[2].max_cut[2] = rim_center[2] - dz_rim;
		
		// upper rim.
		passes[3].min_cut[0] = -1e30; // infinite in xy
		passes[3].max_cut[0] = 1e30;
		passes[3].min_cut[1] = -1e30;
		passes[3].max_cut[1] = 1e30;
		passes[3].min_cut[2] = rim_center[2] + dz_rim;
		passes[3].max_cut[2] = 1e30;

		rim_mask_upper.applyPoolToAllRegions( pass_pool_id[2] );
		rim_mask_lower.applyPoolToAllRegions( pass_pool_id[2] );
	}
	
	const char *out_in[3]= {"IN","OUT", "RIM"};
			
	sprintf(cur_filename, "segment_%s%d.crd", out_in[0], seg_cntr );
	sprintf(cur_segname, "%s%d", out_in[0], seg_cntr ); 

	int gm1_switch =0;

	for( int pass = 0; pass < 2; pass++ )
	{
		srand(seed); // generate the same random numbers.

		double alpha_outside = 1;
		double alpha_inside  = 1;

		if( pass == 1 )
		{
			alpha_outside = sqrt(area_fraction_outside);
			alpha_inside = sqrt(area_fraction_inside);
		}
		int nlipids_placed = 0;
		int nlipids_placed_outside = 0;
		int nlipids_placed_inside = 0;
		int switched = 0;

		int nleaflets = 2;

		for( int tx = 0; tx < n_build_passes; tx++ )
		{
			surface *useSurface = passes[tx].useSurface;
			double *rsurf = passes[tx].rsurf;

			int nregions = passes[tx].theMask->nreg;
			int x_leaflet = passes[tx].structure_take_from;
			double the_strain = passes[tx].strain;

			if( do_leaflet[x_leaflet] == 0 ) continue;


			int *regional_face = (int *)malloc( sizeof(int) * useSurface->nt );
			memset( regional_face, 0, sizeof(int) * useSurface->nt );
	
			int *tri_list = (int *)malloc( sizeof(int) * useSurface->nt );

			surface_mask *theMask = passes[tx].theMask; 

			int *regions_for_face = theMask->reg_for_f;

			for( int r = 0; r < nregions; r++ )
			{
				int the_pool = theMask->getPool(r);
				const struct surface_region *region = theMask->getRegion(r);
				
				struct pool_structure *pool = getPool(the_pool);

				int *leaflet = pool->leaflet;
				double *lipid_xyz = pool->xyz;
				struct atom_rec *at = pool->at;
				int local_nat = pool->nat;
				int *lipid_stop = pool->lipid_stop;
				int *lipid_start = pool->lipid_start;
				int nlipids = pool->nlipids;
				int **local_cycles = pool->cycles;
				int *local_cycle_len = pool->cycle_lengths;
				int local_ncycles = pool->ncycles;
				int flipped = region->flipped;	
				int *local_bonds = pool->bonds;
				int *local_nbonds = pool->nbonds;
				int *local_bond_offsets = pool->bond_offsets;

				if( flipped )
				{
					for( int a = 0; a < local_nat; a++ )
					{
						at[a].x *= -1;
						at[a].z *= -1;
					} 
				}

			
				double Lx = pool->Lx;
				double Ly = pool->Ly;
				double Lz = pool->Lz;
				
				APL[tx] += Lx*Ly/(nlipids/2);

				printf("DOING REGION %d\n", r );
				int N = 0;
		
				double tri_cen[3] = {0,0,0};
		
				int debug_me = 0;
				double patch_area = 0;

				for( int t = 0; t < useSurface->nt; t++ )
				{
					int f = useSurface->theTriangles[t].f;

					if( regions_for_face[f] == r )
					{
						int *ids = useSurface->theTriangles[t].ids;

						if( ids[0] == 66 && ids[1] == 83 && ids[2] == 85 )
						{
							printf("debug trial t %d, face %d\n", t, useSurface->theTriangles[t].f );
						}

						regional_face[f] = 1;
		//				if( t == debug_f )
							//debug_me = 1;
						double rc[3],nc[3];
						useSurface->evaluateRNRM( f, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );
	
						double *v1 = rsurf + 3 * useSurface->theTriangles[t].ids[0];
						double *v2 = rsurf + 3 * useSurface->theTriangles[t].ids[1];
						double *v3 = rsurf + 3 * useSurface->theTriangles[t].ids[2];
			
						patch_area += 0.5 * useSurface->g( f, 1.0/3.0, 1.0/3.0, rsurf ) ;	
						

		//				if( r < natom_names )
		//				printf("%s %lf %lf %lf\n", atom_name[r], rc[0], rc[1], rc[2] );
		
						if( N == 0 )
						{
							tri_cen[0] += rc[0];
							tri_cen[1] += rc[1];
							tri_cen[2] += rc[2];
						}	
						else
						{
							double dr[3] = { rc[0] - tri_cen[0]/N, rc[1] - tri_cen[1]/N, rc[2] - tri_cen[2]/N };
							useSurface->wrapPBC( dr, rsurf+3*nv );
		
							tri_cen[0] += tri_cen[0]/N + dr[0];	
							tri_cen[1] += tri_cen[1]/N + dr[1];	
							tri_cen[2] += tri_cen[2]/N + dr[2];	
						}
		
						tri_list[N] = f; 
						N++; 
					}
				}
		
				tri_cen[0] /= N;
				tri_cen[1] /= N;
				tri_cen[2] /= N;
		
				double best_chi2 = 1e10;
				int best_x = 0;
				for( int xt = 0; xt < N; xt++ )
				{
					int f = tri_list[xt];
		
					double rc[3],nc[3];
					useSurface->evaluateRNRM( f, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );
		
					double dr[3] = { rc[0] - tri_cen[0], rc[1] - tri_cen[1], rc[2] - tri_cen[2] };
			
					useSurface->wrapPBC( dr, rsurf+3*nv );
		
					double r = normalize(dr);
		
					if( f >= nf_faces )
						r += 1e8;
		
					if( r < best_chi2 )
					{
						best_chi2 = r;
						best_x = xt;
					}
				}
		
				int f = tri_list[best_x]; 

				if( region->is_aligned )
					f = region->f_align_on;	


				// pick a lipid on the upper leaflet to put in the center of the face.
			
				double alpha = alpha_outside;
				if( x_leaflet == 0 )
					alpha = alpha_inside;
				int l_cen = rand() % nlipids;
	
				while( leaflet[l_cen] * (flipped ? -1 : 1) != passes[tx].orientation ) //(x_leaflet ? 1 : -1 ) )
					l_cen = rand() % nlipids; 
	
			
				// loop over all lipids. if they are in the face, place them into the coord structure.
			
				double upper_cen[3] = { (flipped?-1:1)*lipid_xyz[3*l_cen+0], lipid_xyz[3*l_cen+1],  (flipped?-1:1)*lipid_xyz[3*l_cen+2] };
				const double *set_x = NULL;

				if( region->is_aligned )
				{
					upper_cen[0] = region->com[0];
					upper_cen[1] = region->com[1];
					upper_cen[2] = region->com[2];
					set_x = region->align_x_on;
				}

				// x, y to u, v'
			
			
				double sim_area = Lx*Ly;

				int del_PBC_x = 1;
				int del_PBC_y = 1;
				if( sim_area / patch_area < 2)
				{
					del_PBC_x = 1+(int)ceil(sqrt(patch_area/sim_area));
					del_PBC_y = 1+(int)ceil(sqrt(patch_area/sim_area));
				}

				if( del_PBC_x > 5 && patch_warning < 5)
				{
					printf("WARNING: PATCH AREAS ARE VERY LARGE COMPARED TO SIMULATION.\n");
					patch_warning += 1;
				}
				for( int l = 0; l < nlipids; l++ )
				for( int dx_pbc = -del_PBC_x; dx_pbc <= del_PBC_x; dx_pbc += 1 )
				for( int dy_pbc = -del_PBC_x; dy_pbc <= del_PBC_x; dy_pbc += 1 )
				{
					if( leaflet[l] != leaflet[l_cen] ) continue;
	//				if( l != l_cen ) continue;
					// if the segment is a protein or glycosphingolipid we'll try to help the user with patch commands.
	
		
					// map the r coords to u/v
			
					double dx =  (flipped?-1:1)*lipid_xyz[3*l+0]-upper_cen[0];
					double dy =  lipid_xyz[3*l+1]-upper_cen[1];
		
					double shift[2] = {dx_pbc * Lx, dy_pbc * Ly};
					while( dx < -Lx/2 ) {dx += Lx; shift[0] += Lx; }
					while( dx >  Lx/2 ) {dx -= Lx; shift[0] -= Lx; }
					while( dy < -Ly/2 ) {dy += Ly; shift[1] += Ly; }
					while( dy >  Ly/2 ) {dy -= Ly; shift[1] -= Ly; }
			
					dx += dx_pbc * Lx;
					dy += dy_pbc * Ly;
	
					double use_r[3] = { alpha * dx, alpha * dy,  (flipped?-1:1)*lipid_xyz[3*l+2] };
					double eval_cen[3];
		
					double spot_u = 1.0/3.0;
					double spot_v = 1.0/3.0;

					if( region->is_aligned )
					{
						spot_u = region->u_align_on;
						spot_v = region->v_align_on;
					}	
	
					int main_f_eval = f;
					double main_u_cen = spot_u;
					double main_v_cen = spot_v;
					int ncrosses = 0;	

					// everything must be evaluated at this spot to retain the x,y to u/v mapping.
					// get the x/y/z coordinate system transported to the distance spot (as determined by use_r)
					double dx_uv[2], dy_uv[2];
					double source_r[3] = { alpha * dx, alpha * dy,  (flipped?-1:1)*lipid_xyz[3*l+2] };
					double save_spot_u = spot_u;
					double save_spot_v = spot_v;
					int fout = useSurface->getCoordinateSystem( f, &spot_u, &spot_v, source_r, -the_strain, (flipped ? -1 : 1 ) *leaflet[l],
							dx_uv, dy_uv, rsurf, regional_face, &ncrosses, set_x ); 

					double w_use = 1.0;
					double w_rim = 0.0;
					double rimp[3] = {0,0,0};
					double rimn[3] = {0,0,0};

					int debug_mode = 0;
					if( !strcasecmp( cur_segname, "IN8" ) )
					{	
						debug_mode = 1;
					}

				
					double test_nrm[3];
					double test_rpt[3];
		
					useSurface->evaluateRNRM( fout, spot_u, spot_v, test_rpt, test_nrm, rsurf );
		
					int okay = 1;
					
					if( 
						test_rpt[0] > passes[tx].min_cut[0] && test_rpt[0] < passes[tx].max_cut[0] &&
						test_rpt[1] > passes[tx].min_cut[1] && test_rpt[1] < passes[tx].max_cut[1] && 
						test_rpt[2] > passes[tx].min_cut[2] && test_rpt[2] < passes[tx].max_cut[2] 
						) 
					{
						okay = 0;
					}
					if( !okay ) continue;
		

					for( int c = 0; c < 3; c++ )
					{
						if( halve[c] )
						{
							double dr_fr = test_rpt[c]/PBC_vec[c][c] - buildData->frac_cen[c];
							while( dr_fr < -0.5 ) dr_fr += 1;
							while( dr_fr > 0.5 ) dr_fr -= 1;
					
							if( dr_fr > 0.25 || dr_fr < -0.25 )
								continue;
						}
					}

					if( regions_for_face[fout] == r && ncrosses < 5 )
					{
						nlipids_placed += 1;
						if( x_leaflet == 0 )
							nlipids_placed_inside += 1;
						else
							nlipids_placed_outside += 1;
	
						if( pass == 0 ) continue;	

						int base_res = cur_res; 
	
						if( cur_size > 0 && (!strncasecmp( at[lipid_start[l]].segid, "GLP", 3) || cur_res > 50 || switched) )
							EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, pairs, &seg_cntr, npairs, npair_space, x_leaflet,
									&cur_size, &cur_natoms, &cur_atom,  &cur_res, &switched, gm1_switch );

						double u_cen = spot_u;
						double v_cen = spot_v;

						int blew_it = 1;
						for( int test_iters = 0; test_iters < 25; test_iters++ )
						{
							if( TestAdd( useSurface, l, lipid_start, lipid_stop, at,
								shift, upper_cen, zero_vec, alpha, 
								main_u_cen, main_v_cen,
								use_r, source_r,
								spot_u, spot_v,
								fout, rsurf,
								(flipped ? -1 : 1 ) * leaflet[l],
								-the_strain,
								dx_uv, dy_uv,
								w_use, w_rim, rimp, rimn,
								x_leaflet, total_lipid_charge,
								&cur_atom, &cur_natoms,
								cur_segname, &cur_segment, &cur_size, &cur_space, &cur_res, 
								buildData,
								local_cycles, local_cycle_len, local_ncycles,
								local_bonds, local_nbonds, local_bond_offsets, 
								doubleBondIndexes, region->mod_region ) )
							{
								blew_it = 0;
								if( !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
									gm1_switch = 1;
								else if( !strncasecmp( at[lipid_start[l]].segid, "GLP3", 4) )
									gm1_switch = 3;
								else
									gm1_switch = 0;
								cur_res++;
						
								if( cur_size > 0 && !strncasecmp( at[lipid_start[l]].segid, "GLP", 3) )
									EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, pairs, &seg_cntr, npairs, npair_space, x_leaflet,
										&cur_size, &cur_natoms,&cur_atom,  &cur_res, &switched, gm1_switch );

								break;
							}
						}
//						if( blew_it ) printf("Blew it for fout: %d\n", fout );
					}
				}

				memset( regional_face, 0, sizeof(int) * useSurface->nt );
				
				if( flipped )
				{
					for( int a = 0; a < local_nat; a++ )
					{
						at[a].x *= -1;
						at[a].z *= -1;
					} 
				}
			}

			APL[tx]/=nregions;

			free(tri_list);
			free(regional_face);

			switched = 1;
		}

		printf("Nlipids placed outside: %d nlipids placed inside: %d\n", nlipids_placed_outside, nlipids_placed_inside);
		
		double likely_area_covered_outside = nlipids_placed_outside *APL[1]; //used_A[1] / (1e-10 + used_nlipids[1]/2);
		double likely_area_covered_inside = nlipids_placed_inside* APL[0]; //used_A[0] / ( 1e-10 + used_nlipids[0]/2);

		area_fraction_outside = likely_area_covered_outside / area_target_outside;
		area_fraction_inside = likely_area_covered_inside / area_target_inside;

		printf("PASS %d area percentage: %lf%% outside %lf%% inside.\n", pass, 100*area_fraction_outside, 100*area_fraction_inside );
	}
	
	int junk = 0;
	if( cur_size > 0 )
		EndSegment( charmmFile, cur_filename, cur_segment, cur_segname, pairs, &seg_cntr, npairs, npair_space, junk,
				&cur_size, &cur_natoms,&cur_atom,  &cur_res, &junk, gm1_switch );

	free(cur_segname);

	if( upper_patch_r )
		free(upper_patch_r );
	if( lower_patch_r )
		free(lower_patch_r );
	
//	*cur_res_in = cur_res;
//	*cur_size_in = cur_size;
}
#endif
