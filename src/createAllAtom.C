#include "interp.h"
#include "input.h"
#include "pdb.h"
#include "dcd.h"
#include "util.h"
#include "mutil.h"
#include <math.h>

static double PP = 12.0;


const char *charmm_header =

"* GENERATED BY CHARMM-GUI (http://www.charmm-gui.org)\n"
"* ASSEMBLY step.\n"
"*\n"
"\n"
"DIMENS CHSIZE 3000000 MAXRES 3000000\n"
"\n"
"! Read topology and parameter files\n"
"stream toppar.str\n"
"\n";

const char *charmm_footer = 
"!\n"
"! Write PSF, coordinates, and information of the assembled system\n"
"!\n"
"\n"
"open write unit 10 card name system.psf\n"
"write psf  unit 10 card\n"
"\n"
"open write unit 10 card name system.crd\n"
"write coor  unit 10 card\n"
"\n"
"stop\n";


struct crd_psf_pair
{
	char CRDfileName[256];
	char PSFfileName[256];
};


void surface::createAllAtom( parameterBlock *block )
{
	double *rsurf = (double *)malloc( sizeof(double) * 3 * (1 + nv) );
	
	get(rsurf);
	rsurf[3*nv+0] = 1.0;
	rsurf[3*nv+1] = 1.0;
	rsurf[3*nv+2] = 1.0;

	// outputs in CHARMM coordinate format

	// breakdown system into as many approximately square patches as possible, with the correct areas?

	char fileName[256];
	sprintf(fileName, "create_%s_charmm.inp", block->jobName );
	FILE *charmmFile = fopen(fileName,"w");

	if( !charmmFile )
	{
		printf("Couldn't open file \"%s\" for writing.\n", fileName );
		exit(1);
	}
	
	fprintf(charmmFile, charmm_header );

	FILE *pdbFile;	

	if( !block->patchPDB )
	{
		printf("Structure building requires a valid pdb file \"patchPDB\"\n");
		exit(1); 
	}
	
	pdbFile = fopen(block->patchPDB,"r");

	if( !pdbFile )
	{
		printf("Couldn't open file \"%s\"\n", block->patchPDB );
		exit(1);
	}

	if( block->patchPSF )
	{
		FILE *psfFile = fopen(block->patchPSF,"r");

		if( !psfFile )
		{
			printf("Couldn't open file \"%s\"\n", block->patchPDB );
			exit(1);
		}

		loadPSF( psfFile );
	}
	else
		loadPSFfromPDB( pdbFile );

	struct atom_rec *at = (struct atom_rec *)malloc( sizeof(struct atom_rec ) * curNAtoms() );
	
	rewind(pdbFile);
	loadPDB( pdbFile, at );	

	fclose(pdbFile);

	double Lx,Ly,Lz,alpha,beta,gamma;
	
	if( PBCD( &Lx,&Ly,&Lz,&alpha,&beta,&gamma) )
	{
		printf("Couldn't read CRYST1 record from PDB.\n");
		exit(1);
	}
	
	// the index where a lipid's atoms start
	int *lipid_start = (int *)malloc( sizeof(int) * curNAtoms() );
	// the index where a lipid's atoms stop
	int *lipid_stop  = (int *)malloc( sizeof(int) * curNAtoms() );
	// the coordinates of that lipid.
	double *lipid_xyz       = (double *)malloc( sizeof(double) * 3 * curNAtoms() );
	int *leaflet            = (int *)malloc( sizeof(int) * curNAtoms() );
	int nlipids = 0;

	char p_segid[256];
	int pres = -1;
	int seg_continuity_mode = 0;
	p_segid[0] = '\0';
	// fill the index

	nlipids=-1;
	for( int a = 0; a < curNAtoms(); a++ )
	{
		if( !strcasecmp( at[a].resname, "TIP3") ) continue;
		if( !strcasecmp( at[a].resname, "SOD") ) continue;
		if( !strcasecmp( at[a].resname, "POT") ) continue;
		if( !strcasecmp( at[a].resname, "CLA") ) continue;

		if( !strncasecmp( at[a].segid, "GLPA", 4) ||
	  	    !strncasecmp( at[a].segid, "PRO", 3) )
			seg_continuity_mode = 1;
		else
			seg_continuity_mode = 0;

		if( (!seg_continuity_mode && (at[a].res != pres)) || strcasecmp( at[a].segid, p_segid) )
		{  
			nlipids++;
			// a new residue. is it a lipid, or protein?
			// for now, assume everything is going in, except water.
			
			lipid_start[nlipids] = a;
			lipid_stop[nlipids] = a;
				
		}
		else
		{
			lipid_stop[nlipids] = a;
		}
		strcpy( p_segid, at[a].segid ); 
		pres = at[a].res;
	}

	// the last "lipid" doesn't get incremented.
	nlipids++;

	// get the bilayer center.

#define N_BINS_MOLDIST 100

        double best_chi2 = 1e10;
	double wrapto = 0;
 
        double moldist[N_BINS_MOLDIST];
        memset( moldist, 0, sizeof(double) * N_BINS_MOLDIST );


	for( int l = 0; l < nlipids; l++ )
	{
		for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
		{
                      double tz = at[p].z;

                      while( tz < 0 ) tz += Lz;
                      while( tz >= Lz ) tz -= Lz;

                      int zb = N_BINS_MOLDIST * tz / Lz; // this is right
                      if( zb < 0 ) zb = 0;
                      if( zb >= N_BINS_MOLDIST ) zb = N_BINS_MOLDIST-1;
                      moldist[zb] += 1;
		}
	}

         for( int zb = 0; zb < N_BINS_MOLDIST; zb++ )
         {
                 double zv = Lz * (zb+0.5) / (double)N_BINS_MOLDIST;
 
                  int zlow  = zb- N_BINS_MOLDIST/2;
                  int zhigh = zlow + N_BINS_MOLDIST;
 
                  double Lzhi2 = 0;
                  for( int iz = zlow; iz < zhigh; iz++ )
                  {
                          double dz = Lz * (iz+0.5) / N_BINS_MOLDIST - zv;
 
                          int iiz = iz;
                          while( iiz < 0 ) iiz += N_BINS_MOLDIST;
                          while( iiz >= N_BINS_MOLDIST ) iiz -= N_BINS_MOLDIST;
 
                          Lzhi2 += moldist[iiz] * (dz) * (dz);
                  }
 
                  if( Lzhi2 < best_chi2 )
                  {
                          best_chi2 = Lzhi2;
                          wrapto = zv;
                  }
         }


	// wrap around z periodic dimension

	for( int l = 0; l < nlipids; l++ )
	{
		while( at[lipid_start[l]].z - wrapto < -Lz/2 ) at[lipid_start[l]].z += Lz;
		while( at[lipid_start[l]].z - wrapto > Lz/2 ) at[lipid_start[l]].z -= Lz;

		double lcom_z = 0;

		for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
		{
			while( at[p].x - at[lipid_start[l]].x < -Lx/2 ) at[p].x += Lx;
			while( at[p].x - at[lipid_start[l]].x >  Lx/2 ) at[p].x -= Lx;
			
			while( at[p].y - at[lipid_start[l]].y < -Ly/2 ) at[p].y += Ly;
			while( at[p].y - at[lipid_start[l]].y >  Ly/2 ) at[p].y -= Ly;
			
			while( at[p].z - at[lipid_start[l]].z < -Lz/2 ) at[p].z += Lz;
			while( at[p].z - at[lipid_start[l]].z >  Lz/2 ) at[p].z -= Lz;
	
			lcom_z += (at[p].z - wrapto);
		}

		if( lcom_z > 0 )
			leaflet[l] = 1;
		else
			leaflet[l] = -1;
	} 

	// subtract off wrapto

	for( int a = 0; a < curNAtoms(); a++ )
		at[a].z -= wrapto;

	// fill lipid positions

	for( int l = 0; l < nlipids; l++ )
	{
		lipid_xyz[3*l+0] = 0;	
		lipid_xyz[3*l+1] = 0;	
		lipid_xyz[3*l+2] = 0;
	
		for( int p = lipid_start[l]; p <= lipid_stop[l]; p++ )
		{
			lipid_xyz[3*l+0] += at[p].x;
			lipid_xyz[3*l+1] += at[p].y;
			lipid_xyz[3*l+2] += at[p].z;
		}

		lipid_xyz[3*l+0] /= (lipid_stop[l] - lipid_start[l] + 1 );
		lipid_xyz[3*l+1] /= (lipid_stop[l] - lipid_start[l] + 1 );
		lipid_xyz[3*l+2] /= (lipid_stop[l] - lipid_start[l] + 1 );
	}


	int *lipid_oppo = (int *)malloc( sizeof(int) * nlipids );


	for( int l = 0; l < nlipids; l++ )
	{
		double best = 1e10;

		lipid_oppo[l] = -1;

		for( int l2 = 0; l2 < nlipids; l2++ )
		{
			if( leaflet[l2] == leaflet[l] ) continue;

			double dr[3] = { 
				lipid_xyz[3*l+0] - lipid_xyz[3*l2+0],
				lipid_xyz[3*l+1] - lipid_xyz[3*l2+1],
				lipid_xyz[3*l+2] - lipid_xyz[3*l2+2] };
			while( dr[0] > Lx/2 ) dr[0] -= Lx;
			while( dr[1] > Ly/2 ) dr[1] -= Ly;
			while( dr[0] < -Lx/2 ) dr[0] += Lx;
			while( dr[1] < -Ly/2 ) dr[1] += Ly;

			double r = normalize(dr);

			if( r < best )
			{	
				lipid_oppo[l] = l2;
				best = r;
			}
		}

		if( lipid_oppo[l] == -1 )
		{
			printf("Couldn't make sense of the bilayer input PDB file.\n");
			printf("Couldn't find a good lipid on the opposite side of the bilayer.\n");
			exit(1);
		}
	}

	// get regions of the bilayer which we will map collectively attempting to leave a minimum of seams.

	int *regions_for_face = (int *)malloc( sizeof(int) * nt );
	int *regions_for_tri = (int *)malloc( sizeof(int) * nt );

	double cur_area,area0;
	area(rsurf,-1, &cur_area,&area0);
		
	// target one fourth of the area?
	int nregions = 3*area0 / (Lx*Ly/4);

	printf("Using %d regions.\n", nregions );

	getRegions(regions_for_tri, nregions );

	for( int t = 0;  t < nt; t++ )
		regions_for_face[theTriangles[t].f] = regions_for_tri[t];

	// Eventually I'd like to place lipids with as few seams,
	// and as little lateral tension inhomogeneity as possible.
	// for now I'll just put them on the faces.

	int *tri_list = (int *)malloc( sizeof(int) * nt );

	int cur_natoms = 0;
	int cur_atom = 1;
	int cur_res  = 1;

	FILE *tempFile = fopen("temp.crd","w");


	const char *atom_name[] = 
	{	
		"H",
		"He",
		"Li",
		"Be",
		"B",
		"C",
		"N",
		"O",
		"F",
		"Na",
		"K",
		"Cl"		
	};

	int natom_names = sizeof(atom_name)/sizeof(const char*);
	
	int cur_size = 0;
	int cur_space = 1024;
	char *cur_segment = (char *)malloc( sizeof(char) * cur_space );
	cur_segment[0] = '\0';
	char *cur_filename = (char *)malloc( sizeof(char) * 1024 );
	char *cur_segname = (char *)malloc( sizeof(char) * 1024 );	

	int seg_cntr = 1;

	sprintf(cur_filename, "segment_SEG%d.crd", seg_cntr );
	sprintf(cur_segname, "SEG%d", seg_cntr ); 

	int npairs = 0;
	int npair_space = 10;
	crd_psf_pair *pairs = (crd_psf_pair *)malloc( sizeof(crd_psf_pair) * npair_space );

	for( int r = 0; r < nregions; r++ )
	{
		int N = 0;

		double tri_cen[3] = {0,0,0};

		for( int t = 0; t < nt; t++ )
		{
			if( regions_for_face[t] == r )
			{
				double rc[3],nc[3];
				evaluateRNRM( t, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );
			
//				if( r < natom_names )
//				printf("%s %lf %lf %lf\n", atom_name[r], rc[0], rc[1], rc[2] );

				if( N == 0 )
				{
					tri_cen[0] += rc[0];
					tri_cen[1] += rc[1];
					tri_cen[2] += rc[2];
				}	
				else
				{
					double dr[3] = { rc[0] - tri_cen[0]/N, rc[1] - tri_cen[1]/N, rc[2] - tri_cen[2]/N };
					wrapPBC( dr, rsurf+3*nv );

					tri_cen[0] += tri_cen[0]/N + dr[0];	
					tri_cen[1] += tri_cen[1]/N + dr[1];	
					tri_cen[2] += tri_cen[2]/N + dr[2];	
				}

				tri_list[N] = t; 
				N++; 
			}
		}

		tri_cen[0] /= N;
		tri_cen[1] /= N;
		tri_cen[2] /= N;

		double best_chi2 = 1e10;
		int best_x = 0;
		for( int xt = 0; xt < N; xt++ )
		{
			int f = tri_list[xt];

			double rc[3],nc[3];
			evaluateRNRM( f, 1.0/3.0, 1.0/3.0, rc, nc, rsurf );

			double dr[3] = { rc[0] - tri_cen[0], rc[1] - tri_cen[1], rc[2] - tri_cen[2] };
	
			wrapPBC( dr, rsurf+3*nv );

			double r = normalize(dr);

			if( r < best_chi2 )
			{
				best_chi2 = r;
				best_x = xt;
			}
		}

		int f = tri_list[best_x]; 

		for( int x_leaflet = 0; x_leaflet < 2; x_leaflet++ )
		{
			// pick a lipid on the upper leaflet to put in the center of the face.
		
			int l_cen = rand() % nlipids;

			while( leaflet[l_cen] != (x_leaflet ? 1 : -1 ) )
				l_cen = rand() % nlipids; 

			int l_opp = lipid_oppo[l_cen];
		
			// loop over all lipids. if they are in the face, place them into the coord structure.
		
			double upper_cen[3] = { lipid_xyz[3*l_cen+0], lipid_xyz[3*l_cen+1], lipid_xyz[3*l_cen+2] };
			double lower_shift[3] = { 
					lipid_xyz[3*l_cen+0] - lipid_xyz[3*l_opp+0],
					lipid_xyz[3*l_cen+1] - lipid_xyz[3*l_opp+1],
					lipid_xyz[3*l_cen+2] - lipid_xyz[3*l_opp+2] };
		
			while( lower_shift[0] >   Lx/2 ) lower_shift[0] -= Lx;
			while( lower_shift[0] <  -Lx/2 ) lower_shift[0] += Lx;
			while( lower_shift[1] >   Ly/2 ) lower_shift[1] -= Ly;
			while( lower_shift[1] <  -Ly/2 ) lower_shift[1] += Ly;
			while( lower_shift[2] >   Lz/2 ) lower_shift[2] -= Lz;
			while( lower_shift[2] <  -Lz/2 ) lower_shift[2] += Lz;
			
		
			// x, y to u, v'
		
			for( int l = 0; l < nlipids; l++ )
			{
				if( leaflet[l] != leaflet[l_cen] ) continue;
//				if( l != l_cen ) continue;
				// if the segment is a protein or glycosphingolipid we'll try to help the user with patch commands.

	
				// map the r coords to u/v
		
				double dx = lipid_xyz[3*l+0]-upper_cen[0];
				double dy = lipid_xyz[3*l+1]-upper_cen[1];
	
				double shift[2] = {0,0};
				while( dx < -Lx/2 ) {dx += Lx; shift[0] += Lx; }
				while( dx >  Lx/2 ) {dx -= Lx; shift[0] -= Lx; }
				while( dy < -Ly/2 ) {dy += Ly; shift[1] += Ly; }
				while( dy >  Ly/2 ) {dy -= Ly; shift[1] -= Ly; }
			
				double use_r[3] = { dx, dy, lipid_xyz[3*l+2] };
				double eval_cen[3];
	
				double spot_u = 1.0/3.0;
				double spot_v = 1.0/3.0;


				int main_f_eval = f;
				double main_u_cen = spot_u;
				double main_v_cen = spot_v;

				// everything must be evaluated at this spot to retain the x,y to u/v mapping.
				int fout = evaluate_at( eval_cen, use_r, f, &spot_u, &spot_v, rsurf, leaflet[l] );
	
	
				if( regions_for_face[fout] == r )
				{
					int base_res = cur_res; 

					if( !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
					{	
						// ALWAYS terminate the current segment, regardless.
						
						if( cur_size > 0 )
						{
							fprintf(charmmFile, 
							"\n"
							"open read card unit 10 name \"%s\"\n"
							"read sequence coor card unit 10\n"
							"generate %s setup warn first none last none\n"
							"open read unit 10 card name \"%s\"\n"
							"read coor unit 10 card resid\n"						
							"\n"
							"open write unit 10 card name \"%s.psf\"\n"
							"write psf  unit 10 card\n"
							"delete atom sele atom * * * end\n"
							, cur_filename, cur_segname, cur_filename, cur_segname );

							FILE *crdFile = fopen( cur_filename, "w");
							printCRDHeader( crdFile, cur_natoms );
							fprintf(crdFile, "%s", cur_segment );
							fclose(crdFile);

							if( npairs == npair_space )
							{
								npair_space *= 2;

								pairs = (crd_psf_pair *)realloc( pairs, sizeof(crd_psf_pair) * npair_space );
							}

							strcpy( pairs[npairs].CRDfileName, cur_filename );
							char psf_file[256];
							sprintf(psf_file, "%s.psf", cur_segname );
							strcpy( pairs[npairs].PSFfileName, psf_file ); 

							npairs++;
						
							seg_cntr++;		
							sprintf(cur_filename, "segment_SEG%d.crd", seg_cntr );
							sprintf(cur_segname, "SEG%d", seg_cntr ); 
						}					
					
						cur_size = 0;
						cur_natoms = 0;
						cur_segment[0] = '\0';
						cur_atom = 1;
						cur_res  = 1;
					}

					double u_cen = spot_u;
					double v_cen = spot_v;
					double wrap_to[3] = { 0,0,0};
	
					int pres = at[lipid_start[l]].res;
	
					for( int xa = lipid_start[l]; xa <= lipid_stop[l]; xa++ )
					{
						if( at[xa].res != pres )
							cur_res++; 
						pres = at[xa].res;

						double xsave = at[xa].x;
						double ysave = at[xa].y;
						double zsave = at[xa].z;
						int at_save = at[xa].bead;
						int res_save = at[xa].res;
	
						double dx = xsave-upper_cen[0]+shift[0];
						double dy = ysave-upper_cen[1]+shift[1];
		
						double use_r[3] = { dx, dy, zsave };
						double eval[3];
	
						double transp_u = main_u_cen;
						double transp_v = main_v_cen;
						evaluate_at( eval, use_r, main_f_eval, &transp_u, &transp_v, rsurf, leaflet[l] );
	
						at[xa].x = eval[0];
						at[xa].y = eval[1];
						at[xa].z = eval[2];
					
						if( xa > lipid_start[l] )
						{
							double dr[3] = { at[xa].x - wrap_to[0], at[xa].y - wrap_to[1], at[xa].z - wrap_to[2] };
							wrapPBC( dr, rsurf+3*nv );
	
							at[xa].x = wrap_to[0] + dr[0];
							at[xa].y = wrap_to[1] + dr[1];
							at[xa].z = wrap_to[2] + dr[2];
						}
						else
						{
							wrap_to[0] = at[xa].x;
							wrap_to[1] = at[xa].y;
							wrap_to[2] = at[xa].z;
						}
	
	
						at[xa].bead = cur_atom;
						at[xa].res  = cur_res;
						at[xa].segRes = cur_res;

						char temp_segid[256];
						sprintf(temp_segid, "MEMB");
						char *tmp = at[xa].segid;
						at[xa].segid = cur_segname;
	
						if( cur_size + 1024 > cur_space )
						{	
							cur_space += 1024;
							cur_segment = (char *)realloc( cur_segment, sizeof(char) * cur_space );
						}

						printSingleCRD( cur_segment+cur_size, at+xa );
						cur_size += strlen(cur_segment+cur_size);
						cur_natoms++;
//						printSingleCRD( tempFile, at+xa ); 
						at[xa].segid = tmp;
						at[xa].bead = at_save;
						at[xa].res = res_save;
	
						at[xa].x = xsave;
						at[xa].y = ysave;
						at[xa].z = zsave;
	
						cur_atom++;

					}
				
					cur_res++;
					
					if( !strncasecmp( at[lipid_start[l]].segid, "GLPA", 4) )
					{
						fprintf(charmmFile, 
						"\n"
						"open read card unit 10 name \"%s\"\n"
						"read sequence coor card unit 10\n"
						"generate %s setup warn first none last none\n"
						"open read unit 10 card name \"%s\"\n"
						"read coor unit 10 card resid\n"						
						"\n", cur_filename, cur_segname, cur_filename );

						fprintf(charmmFile, "patch CERB %s %d %s %d setup warn\n", cur_segname, 2, cur_segname, 1 );
						fprintf(charmmFile, "patch 14BB %s %d %s %d setup warn\n",  cur_segname,2,  cur_segname,3 );
						fprintf(charmmFile, "patch 14BA %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,4 );
						fprintf(charmmFile, "patch 13BB %s %d %s %d setup warn\n",  cur_segname,4,  cur_segname,5 );
						fprintf(charmmFile, "patch SA23AB %s %d %s %d setup warn\n",  cur_segname,3,  cur_segname,6 );

						fprintf(charmmFile, 
						"open write unit 10 card name \"%s.psf\"\n"
						"write psf  unit 10 card\n"
						"delete atom sele atom * * * end\n"
						, cur_segname );
						
						FILE *crdFile = fopen( cur_filename, "w");
						printCRDHeader( crdFile, cur_natoms );
						fprintf(crdFile, "%s", cur_segment );
						fclose(crdFile);
						

						if( npairs == npair_space )
						{
							npair_space *= 2;

							pairs = (crd_psf_pair *)realloc( pairs, sizeof(crd_psf_pair) * npair_space );
						}

						strcpy( pairs[npairs].CRDfileName, cur_filename );
						char psf_file[256];
						sprintf(psf_file, "%s.psf", cur_segname );
						strcpy( pairs[npairs].PSFfileName, psf_file ); 

						npairs++;
						cur_natoms = 0;
						cur_size = 0;
						cur_segment[0] = '\0';	
						cur_atom = 1;
						cur_res  = 1;
						seg_cntr++;		
						sprintf(cur_filename, "segment_SEG%d.crd", seg_cntr );
						sprintf(cur_segname, "SEG%d", seg_cntr ); 
					}	
				}
	
			}
		}
	}

	if( cur_size > 0 )
	{
		fprintf(charmmFile, 
		"\n"
		"open read card unit 10 name \"%s\"\n"
		"read sequence coor card unit 10\n"
		"generate %s setup warn first none last none\n"
		"open read unit 10 card name \"%s\"\n"
		"read coor unit 10 card resid\n"						
		"\n", cur_filename, cur_segname, cur_filename );

		fprintf(charmmFile, 
		"open write unit 10 card name \"%s.psf\"\n"
		"write psf  unit 10 card\n"
		"delete atom sele atom * * * end\n"
		, cur_segname );
		
		FILE *crdFile = fopen( cur_filename, "w");
		printCRDHeader( crdFile, cur_natoms );
		fprintf(crdFile, "%s", cur_segment );
		fclose(crdFile);

		if( npairs == npair_space )
		{
			npair_space *= 2;

			pairs = (crd_psf_pair *)realloc( pairs, sizeof(crd_psf_pair) * npair_space );
		}

		strcpy( pairs[npairs].CRDfileName, cur_filename );
		char psf_file[256];
		sprintf(psf_file, "%s.psf", cur_segname );
		strcpy( pairs[npairs].PSFfileName, psf_file ); 

		npairs++;
	}

	for( int p = 0; p < npairs; p++ )
	{
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].PSFfileName );
		if( p == 0 )
			fprintf(charmmFile, "read psf card unit 10\n" );	
		else
			fprintf(charmmFile, "read psf card append unit 10\n" );	
		fprintf(charmmFile, "close unit 10\n" );	
		fprintf(charmmFile, "open unit 10 card read name \"%s\"\n", pairs[p].CRDfileName );	
		fprintf(charmmFile, "read coor card unit 10 resid\n" );	
		fprintf(charmmFile, "close unit 10\n" );
		fprintf(charmmFile, "\n");	
		
	}

	fprintf(charmmFile, charmm_footer );

	free(regions_for_face);
	free(tri_list);
	free(rsurf);
}


int surface::evaluate_at( double eval[3], double dr[3], int f, double *u, double *v, double *rsurf, int leaflet )
{
	double r_cen[3];	
	double r_nrm[3];
	double gmetric[4];
	double gmat_u, gmat_v;
	double drdu[3], drdv[3];
	
	double u_cen = *u;
	double v_cen = *v;

	double transp_cen[3], transp_nrm[3];

	evaluateRNRM( f, u_cen, v_cen, transp_cen, transp_nrm, rsurf ); 

	double eval_in[3] = { 
		transp_cen[0] + transp_nrm[0] * dr[2], 
		transp_cen[1] + transp_nrm[1] * dr[2], 
		transp_cen[2] + transp_nrm[2] * dr[2] 
		};
	ru( f, u_cen, v_cen,  rsurf, drdu ); 
	rv( f, u_cen, v_cen,  rsurf, drdv ); 
	double lru = sqrt(drdu[0]*drdu[0]+drdu[1]*drdu[1]+drdu[2]*drdu[2]);
	double lrv = sqrt(drdv[0]*drdv[0]+drdv[1]*drdv[1]+drdv[2]*drdv[2]);
	
	double dp = (drdu[0]*drdv[0] + drdu[1]*drdv[1] + drdu[2]*drdv[2]);
	
	// drdu and o_drdv are orthonormal unit vectors.
	// they are paired with coordinates up and vp.
	
	double o_drdu[3] = { drdu[0] / lru, drdu[1] / lru, drdu[2] / lru };
	double o_drdv[3] = { drdv[0] / lrv - o_drdu[0]*dp/lru/lrv, 
		             drdv[1] / lrv - o_drdu[1]*dp/lru/lrv, 
		             drdv[2] / lrv - o_drdu[2]*dp/lru/lrv };
	double lscale = normalize(o_drdv);

	// solve u drdu + v drdv == up o_drdu + vp o_drdv in general:
	
	double tr_22 = (o_drdv[0] * o_drdv[0] + o_drdv[1] * o_drdv[1] + o_drdv[2] * o_drdv[2])/(o_drdv[0] * drdv[0] + o_drdv[1] * drdv[1] + o_drdv[2] * drdv[2]);
	
	// this is the transform from up,vp to u, v.
	
	double transform[4] = { 
		1 / (lru),	-tr_22 * dp/(lru*lru),
		0,		tr_22 
	};
	
	// get curvature information

	double c1, c2;
	double cvec1[2], cvec2[2];

	double ctot = c(f,u_cen,v_cen,rsurf,cvec1,cvec2,&c1,&c2);

	// use the cvec1 and cvec2 as the x/y coordinate system.

	double vec_c1[3] = { cvec1[0] * drdu[0] + cvec1[1] * drdv[0],
			     cvec1[0] * drdu[1] + cvec1[1] * drdv[1],
			     cvec1[0] * drdu[2] + cvec1[1] * drdv[2] };
	double vec_c2[3] = { cvec2[0] * drdu[0] + cvec2[1] * drdv[0],
			     cvec2[0] * drdu[1] + cvec2[1] * drdv[1],
			     cvec2[0] * drdu[2] + cvec2[1] * drdv[2] };
	
	

	double vdp  = vec_c1[0] * vec_c2[0] + vec_c1[1] * vec_c2[1] + vec_c1[2] * vec_c2[2];
	double lv1 = normalize(vec_c1);
	double lv2 = normalize(vec_c2);

/*
	// this is u-prime and v-prime:	

	double up = dr[0];
	double vp = dr[1];

	// up uvec = uvec up 

	double du = up * transform[0] + vp * transform[1];
	double dv = up * transform[2] + vp * transform[3];
*/

	double dc1 = dr[0] / lv1;
	double dc2 = dr[1] / lv2;
	double du,dv;
	double z_scaled = dr[2];	

	if( leaflet == 1 && fabs(dr[2]-PP) < 1 )
	{
	}

	if( leaflet == 1 )
	{
//		double scale1 =  (1 + c1 * (PP-dr[2]));
//		double scale2 =  (1 + c2 * (PP-dr[2]));

		// these are scalings needed for displacement at the bilayer midplane to get the proper distances at the neutral surface (PP)
		double scale1 = (1- c1 * (PP-dr[2]))/(1+c1*PP);
		double scale2 = (1- c2 * (PP-dr[2]))/(1+c2*PP);

		// if scale1 is less than 1, it means that the z length has shrunk (the x dimension is larger at the midplane and so the particle's midplane displacement must be scaled down).



		double lat_scale = scale1*scale2;

		dc1 *= scale1;
		dc2 *= scale2;

		double z =dr[2];
		double scale = (1+c1*PP) * (1+c2*PP);
		z_scaled = scale * PP - (PP -z) * (1+(PP-z)*c1)*(1+(PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 
	}
	else
	{
		//double scale1= (1 - c1 * (-PP-dr[2]));
		//double scale2= (1 - c2 * (-PP-dr[2]));
		double scale1 = (1+ c1 * (-PP-dr[2]))/(1-c1*(-PP));
		double scale2 = (1+ c2 * (-PP-dr[2]))/(1-c2*(-PP));
		

		double lat_scale = scale1*scale2;
		dc1 *= scale1;
		dc2 *= scale2;
		//z_scaled = dr[2] * (1+c1*dr[2]) * (1+c2*dr[2]);
		double z =dr[2];
		double scale = (1+c1*PP) * (1+c2*PP);
		//z_scaled = -scale * PP - (-PP -z) * scale1 * scale2;
		z_scaled = -scale * PP - (-PP -z) * (1-(-PP-z)*c1)*(1-(-PP-z)*c2);
	
		du = cvec1[0] * dc1 + cvec2[0] * dc2; 
		dv = cvec1[1] * dc1 + cvec2[1] * dc2; 

	}



	int fp = f;
	int done = 0;

	while( ! done )
	{
		int f2 = nextFace( fp, &u_cen, &v_cen, &du, &dv, rsurf );

		if( f2 == fp ) 
			done = 1;

		fp = f2;
	}	

	double rp[3];
	double np[3];
	evaluateRNRM( fp, u_cen, v_cen, rp, np, rsurf ); 

	


	eval[0] = rp[0] + np[0] * z_scaled; 
	eval[1] = rp[1] + np[1] * z_scaled; 
	eval[2] = rp[2] + np[2] * z_scaled; 
	
	double dr_out[3] = { eval[0] - eval_in[0], eval[1] - eval_in[1], eval[2] - eval_in[2] };
	double rout = normalize(dr_out);
	double rin = sqrt(dr[0]*dr[0]+dr[1]*dr[1]);

//	printf("%lf c1: %lf c2: %lf out_len %lf orig len %lf\n", dr[2], c1, c2, rout, rin); 					

	*u = u_cen;
	*v = v_cen;

	return fp;
}		
